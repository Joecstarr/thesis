{"version":"1","records":[{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/abstract","position":0},{"hierarchy":{"lvl1":""},"content":"The enumeration of provably unique mathematical knots, tabulation, has been a core area of research\nfor over 150 years. One important advancement in this area was Conway’s development of a building\nblock for knots, the tangles. Formally, a n-string tangle is a portion of a knot diagram enclosed\nin a Jordan curve that intersects the knot in exactly 2n points. The tabulation of the two string\ntangles, Conway’s building blocks for knots, has been called:\n\nThe most important missing infrastructure project in knot theory\n\nDr. Dror Bar-Natan \n\nBar-Natan, n.d.\n\nWithout such a table of tangles, researchers are in the position of a chemist who possesses a table\nof fatty acids but no periodic table. In this thesis we answer, in part, this call.\n\nThis thesis develops the theory needed to tabulate tables of successively more complex classes of\ntangles. We start with the rational and Montesinos tangles and then conclude with the arborescent\ntangles, often called the algebraic tangles. For each of these classes of tangles, we additionally\ndevelop a collection of software designs used to efficiently and scalably compute tables of these\ntangles to high crossing number (19). We will also discuss ways that the accessibility of knot\ntheory and in particular tabulation make the domain a candidate for undergraduate research. As part\nof our discussion of undergraduate research, we will outline a software engineering process\nparticularly suited for undergraduate research in knot theory, as well as a model life cycle for an\nundergraduate research experience in computational knot theory.\n\nThis material is based upon work supported by the National Science Foundation under Award No.\nDMS-2038103.\n\nAny opinions, findings, and conclusions or recommendations expressed in this material are those of\nthe author and do not necessarily reflect the views of the National Science Foundation.","type":"content","url":"/abstract","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/lay-summary","position":0},{"hierarchy":{"lvl1":""},"content":"The tabulation, creation of a list, of mathematical knots has been a core area of mathematics\nresearch for over 150 years. A key breakthrough in knot tabulation was Conway’s development of a\nbuilding block for knots, the two string tangle. A two string tangle is a portion of a mathematical\nknot bound within a ball and intersecting that ball in exactly four points. A table of these objects\nhas been called:\n\nThe most important missing infrastructure project in knot theory\n\nDr. Dror Bar-Natan \n\nBar-Natan, n.d.\n\nWithout such a table of tangles, mathematicians and scientists are in the position of a chemist who\npossesses a table of fatty acids but no periodic table. In this thesis we answer, in part, this\ncall.\n\nAs we progress through this thesis, we produce successively larger and more complete tables of\ntangles. Each table we produce requires the development of the mathematical theory demonstrating\nthat what we have produced is what we say it is. Then, for each tangle type we develop the theory\nfor, we also develop a collection of software designs used to convince a computer to quickly\ngenerate large tables of tangles. We will also discuss ways that the accessibility of knot theory\nand in particular tabulation make this domain a candidate for undergraduate research. As part of our\ndiscussion of undergraduate research, we will outline a software engineering process particularly\nsuited for undergraduate research in knot theory, as well as a model life cycle for an undergraduate\nresearch experience in computational knot theory.","type":"content","url":"/lay-summary","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":""},"content":"","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research"},"type":"lvl1","url":"/future-work","position":0},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research"},"content":"In this chapter, we describe the future research directions for the tabulation of tangles. The\nfuture directions take two forms. First, the direct next steps to the work of this thesis\n(\n\nSection 8.1). Second, an undergraduate research research experience\nprogram with a collection of undergraduate problems (\n\nSection 8.2).\n\n prettier-ignore-start ","type":"content","url":"/future-work","position":1},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl2":"Continued Tabulation"},"type":"lvl2","url":"/future-work#sec-future-work-continued-tabulation","position":2},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl2":"Continued Tabulation"},"content":" prettier-ignore-end \n\nIn this section, we describe the next steps for what has been discussed in\n\n\nChapter 6 Tabulation. The first item to tackle in our future\ntabulation work is the reconciliation of our table of arborescent tangles with the algebraic table\nproduced by Gren, Sulkowska, and Gabrovšek \n\nGren et al., 2025. Following this\nour efforts take two forms, first a collection of minimalization problems for the data we have\ngenerated. Second, is the expansion of this work to cover the complete set of two string tangles,\nthe arborescent and the polygonal.\n\n","type":"content","url":"/future-work#sec-future-work-continued-tabulation","position":3},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl3":"Minimalization of Arborescent Tangles","lvl2":"Continued Tabulation"},"type":"lvl3","url":"/future-work#minimalization-of-arborescent-tangles","position":4},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl3":"Minimalization of Arborescent Tangles","lvl2":"Continued Tabulation"},"content":"As we discussed in \n\nSection 6.2.2.5, that RLITT are often non-minimal arborescent representatives\nof a tangle. In fact, minimal arborescent representations may not be minimal tangle representations.\nConway gives an example \n\nConway, 1970 where an arborescent (algebraic) knot is\ntransformed into a minimal polygonal knot (\n\nTangle insertions). In \n\nFigure 1 we\nrephrase Conway’s example for tangles.\n\n\n\nFigure 1:An arborescent tangle being turned into a polygonal tangle via a sequence of\ninterpolated Reidemeister moves.\n\nThis leads to two items that must be addressed to ensure the list of tangles contains minimal\ndiagrams.","type":"content","url":"/future-work#minimalization-of-arborescent-tangles","position":5},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl4":"Identification of Minimal Arborescent Tangle Representations","lvl3":"Minimalization of Arborescent Tangles","lvl2":"Continued Tabulation"},"type":"lvl4","url":"/future-work#identification-of-minimal-arborescent-tangle-representations","position":6},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl4":"Identification of Minimal Arborescent Tangle Representations","lvl3":"Minimalization of Arborescent Tangles","lvl2":"Continued Tabulation"},"content":"The first item, and most straightforward to address, is the identification of a minimal arborescent\nrepresentative of a given RLITT \\Gamma. This requires the identification of the weighted planar\ntree related to \\Gamma whose TCN is minimal. We saw in \n\nSection 6.2.2.5 the ways canonization\ncan increase complexity in a weighted planar tangle tree. To take \\Gamma to its minimal form, we\nwill need to develop the theory for and an implementation of an efficient algorithm to\nsystematically de-canonize \\Gamma into its minimal arborescent form.","type":"content","url":"/future-work#identification-of-minimal-arborescent-tangle-representations","position":7},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl4":"Identification of Minimal Representations for Arborescent Tangles","lvl3":"Minimalization of Arborescent Tangles","lvl2":"Continued Tabulation"},"type":"lvl4","url":"/future-work#identification-of-minimal-representations-for-arborescent-tangles","position":8},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl4":"Identification of Minimal Representations for Arborescent Tangles","lvl3":"Minimalization of Arborescent Tangles","lvl2":"Continued Tabulation"},"content":"Second, and more challenging, is the identification of the minimal representative of a given\narborescent tangle. That is, identifying the minimal representative, arborescent or otherwise as in\n\n\nFigure 1. This task requires the development of a classification of the subtrees of\na weighted planar tree that correspond to moves of the type similar to that seen in\n\n\nFigure 1. The complexity of this task is compounded by the fact that the family of\npolygon graphs allowing these types of moves is infinite (easily shown via an induction). Further,\nthe moves that enable arborescent tangles that are minimally polygonal are not limited to the moves\non the marked 6^{**} (\n\nFigure 1). We can see a second class in\n\n\nFigure 2.\n\n\n\nFigure 2:An arborescent tangle turned into a polygonal tangle.\n\n","type":"content","url":"/future-work#identification-of-minimal-representations-for-arborescent-tangles","position":9},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl3":"Polygonal Tangles","lvl2":"Continued Tabulation"},"type":"lvl3","url":"/future-work#polygonal-tangles","position":10},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl3":"Polygonal Tangles","lvl2":"Continued Tabulation"},"content":"We now discuss the expansion of the tangle tables to include all polygonal tangles up to a target\ncrossing number. Expanding tangle tables to include the polygonal tangles is useful as at high\ncrossing numbers, the polygonal tangles dominate the arborescent tangles. Unfortunately, for the\npolygonal case, we lack a general classification result. Meaning, as it stands, we have no\ntheoretical mechanism for direct generation of unique representatives for a polygonal tangle as we\nhave done with the classes of tangle in this thesis. The development of a general classification for\npolygonal tangles is difficult, at least as difficult as a general classification of knots. With\nthis in mind, we will discuss two possible directions for expanding the polygonal tangles.","type":"content","url":"/future-work#polygonal-tangles","position":11},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl4":"Ad Hoc Classification of Constellations","lvl3":"Polygonal Tangles","lvl2":"Continued Tabulation"},"type":"lvl4","url":"/future-work#ad-hoc-classification-of-constellations","position":12},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl4":"Ad Hoc Classification of Constellations","lvl3":"Polygonal Tangles","lvl2":"Continued Tabulation"},"content":"In \n\nTangle insertions, we discussed constellations \n\nConnolly, 2021\nused for generation of polygonal tangles via insertion. The crossing number of a polygonal tangle is\nbounded below by the vertex count of its constellation. So the number of constellations represented\nat reasonable crossing numbers is small. Additionally, when the difference between crossing number\nand vertex count is low, many of the inserted tangles will have low crossing numbers, again bounding\ncomplexity. In his thesis work, Connolly \n\nConnolly, 2021 enumerates\nthe ten smallest constellations, those with ten or fewer vertices.\n\nNote\n\nIt’s worth noting that expanding the table of constellations for a polygon graph is computationally\nhard, shown NP-complete by Cook\n\nCook, 1971.\n\nWith low vertex count polygons and at low crossing number, developing an ad hoc classification\nresult for each constellation may be a fruitful approach. For example, consider the constellation\nseen in \n\nFigure 3, we can enumerate the possible crossing numbers and locations for\ntangles to be inserted, \n\nTable 1.\n\n\n\nFigure 3:The unique constellation for 6^{\\ast\\ast}\n\nWe see that up to 7 crossings this constellation only admits rational insertions, at 8 crossings we\nsee our first Montesinos. Completing an analysis of the possibilities for insertion may reveal\npatterns that allow a classification of this 6^{**} constellation. Even partial results in this\narena may yield more efficient heuristics when utilizing the methodology in \n\nSection 8.1.2.2.\n\nTable 1:Possible insertions of 6^{\\ast\\ast} by crossing number.\n\nCrossing Number\n\nPossible Crossing numbers for insertion\n\n5\n\n\\ast.1.1.1.1.1\n\n6\n\n\\begin{aligned}\\ast.2.1.1.1.1,\\ast.1.2.1.1.1\\\\\\ast.1.1.2.1.1,\\ast.1.1.1.2.1,\\\\\\ast.1.1.1.1.2\\end{aligned}\n\n7\n\n\\begin{aligned}\\ast.1.1.1.2.2,*.1.1.2.1.2\\\\\\ast.1.1.2.2.1,*.1.2.1.1.2,\\\\\\ast.1.2.1.2.1,*.1.2.2.1.1,\\\\\\ast.2.1.1.1.2,*.2.1.1.2.1,\\\\\\ast.2.1.2.1.1,*.2.2.1.1.1,\\\\\\ast.3.1.1.1.1,*.1.3.1.1.1,\\\\\\ast.1.1.3.1.1,*.1.1.1.3.1,\\\\\\ast.1.1.1.1.3\\end{aligned} prettier-ignore-start ","type":"content","url":"/future-work#ad-hoc-classification-of-constellations","position":13},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl4":"Brute Force Tabulation","lvl3":"Polygonal Tangles","lvl2":"Continued Tabulation"},"type":"lvl4","url":"/future-work#subsubsec-fw-brute","position":14},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl4":"Brute Force Tabulation","lvl3":"Polygonal Tangles","lvl2":"Continued Tabulation"},"content":" prettier-ignore-end \n\nWithout a full or partial classification of the polygonal tangles, we must take an alternative\napproach to what we have seen in this thesis. That alternative is the brute force, two pass\nenumeration strategy used in previous knot tabulation efforts\n\n\nDowker & Thistlethwaite, 1983\n\nHoste et al., 1998\n\nBurton, 2020\nand outlined in \n\nSection 5.1. The key difficulty in this methodology is the selection\nof invariants that combine to uniquely identify tangles. This difficulty is due to the fast growth\nrate for the count of tangles of a given crossing number. This growth rate means any invariant that\nis selected must have an efficient computation strategy. If, for example, as Burton did\n\n\nBurton, 2020, we select hyperbolic volume, we may be able to distinguish a large\nportion of tangles, however computation for crossing numbers as low as 10 will be intractable due to\nthe per tangle time to compute the volume. This says nothing about the raw storage needed to hold\nthe computed and partial data. A seemingly better choice are invariants (\n\nSection 5.2.4) which\nhave polynomial time computations, such as those introduced by van der Veen and Bar-Natan (to be\npublished \n\nVeen & Bar-Natan, n.d.). While weaker than hyperbolic volume, these invariants\nare stronger than the polynomial invariants and faster than both to compute. Statistics for\npolynomial invariants can be found in Maguire’s thesis work \n\nMaguire, n.d..\n\n prettier-ignore-start ","type":"content","url":"/future-work#subsubsec-fw-brute","position":15},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl2","url":"/future-work#sec-future-work-tabulation","position":16},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl2":"Tabulation as Undergraduate Research"},"content":" prettier-ignore-end ","type":"content","url":"/future-work#sec-future-work-tabulation","position":17},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl3":"A Research Experience Program for Undergraduates","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl3","url":"/future-work#a-research-experience-program-for-undergraduates","position":18},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl3":"A Research Experience Program for Undergraduates","lvl2":"Tabulation as Undergraduate Research"},"content":"The accessibility of knot theory was discussed in \n\nSection 4.1. This section\nelaborates on how that accessibility can be leveraged to engage undergraduates in research.\nThroughout this thesis, we have investigated and observed the depth and complexity of tabulation. We\nhave seen how easily portions of complex tabulation problems can be “peeled off” and decomposed as\nself-contained problems. Additionally, we discussed product management training\n(\n\nSection 7.1.2) and developed a software engineering life cycle (\n\nSection 7.1.3) for use\nin organizing undergraduate research. These self contained problems combined with our processes,\nproduce a research experience program ideal for undergraduates. The research experience program can\nbe enhanced by sequencing problems with a gradual release of responsibility model as described by\nFisher and Frey \n\nFisher & Frey, 2013.\n\nWe now outline a multi-semester program for training undergraduates, beginning when those students\nhave only lower division (college algebra level) maturity. To begin, we engage in directed reading\nwith low level accessible texts such as this thesis or The Knot Book: An Elementary Introduction to\nthe Mathematical Theory of Knots by Adams \n\nAdams, 2004. When the student has\ngained a basic understanding of knots, a structured play problem (potentially non-original work) can\nbe introduced. Fitting the need here are problems such as: the sculpting and 3D printing of stick\nknots in a program such as Blender or OpenSCAD \n\nCreate Stick Knots: Lower Division Student, the creation of knot\nmosaics \n\nCreate Knot Mosaics: Lower Division Student, or quilting Celtic knots \n\nCreating Celtic Knots: Lower Division Student. The goal of such an activity is\nto build wonder and cultivate confidence in the students investigation skills.\n\nAs the student matures, their investigation skills improve, and their knowledge base deepens, and\nthey can be presented with more complex reading and novel research problems. Depending on the\nstudent’s interest, we present additional but more advanced readings such as LinKnot\n\n\nJablan & Sazdanović, 2007 or accessible research papers such as Burton\n\n\nBurton, 2020. We should encourage freedom in these readings, allowing students to\nselect sections and formulate questions of their own. At this level, problems should still be well\nstructured having a clear path from start to finish but requiring the filling in of gaps with\noriginal work. We should consider problems such as the translation of notations as in\n\n\nSection 8.2.3.3, or the computation of a well understood invariant, as in \n\nSection 8.2.3.2.\n\nThe program culminates with a mature undergraduate researcher ready to tackle complex problems. At\nthis point we expect the student to have mature reading and reasoning skills but perhaps lack skills\nsuch as literature review. Support for reading at this stage should be focused on assisting students\nin finding answers rather than answers being provided. Students may be prepared to formulate a\nresearch question of their own and this should be encouraged; however presenting students with ideas\nto build on or select from is beneficial. An ideal problem here should fit students interests and\nhave a clear goal but perhaps no clear starting point, for example the random tangle sampling seen\nin \n\nRandom Tangle Sampling: Upper Division Student.","type":"content","url":"/future-work#a-research-experience-program-for-undergraduates","position":19},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl3":"Infrastructure of a Tabulation Program","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl3","url":"/future-work#infrastructure-of-a-tabulation-program","position":20},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl3":"Infrastructure of a Tabulation Program","lvl2":"Tabulation as Undergraduate Research"},"content":"One key issue that must be addressed in a tabulation research program is computational needs.\nComputing on knots and tangles is not necessarily a computationally challenging task. Many problems\nare simple to describe computationally and have efficient implementations. The primary challenge for\ntabulation research stems from the raw scale of the dataset, as both the knot and tangle datasets\ngrow exponentially. This exponential growth of the data gives us two primary areas of concern, time\nto compute and space to store. Even if a problem has a nice constant time or linear time solution,\ndoing a computation on every knot or tangle in our dataset turns the problem into an exponential\none, a computational “death by a thousand cuts”.\n\nGenerally when research questions run up against computational time constraints, solutions take one\nof two forms, vertical scaling or horizontal scaling. We will explain the two by analogy. Imagine we\nare trying to move a large boulder with a bulldozer that is just not powerful enough for the job. We\ncan trade in our bulldozer for a bigger more powerful bulldozer that will push the rock without a\nproblem, this would be vertical scaling. Alternatively, we can blow up the boulder and trade in our\nbulldozer for multiple smaller bulldozers, each able to simultaneously move bits of the boulder,\nthis would be horizontal scaling. In our tabulation case, we could feasibly use either solution. If\nwe vertically scale, we could complete each computation faster. This makes sense for some\ncomputations where each computation is slow such as hyperbolic volume. For other computations, like\nthe grafting seen in \n\nSection 6.2.4.2, each computation requires such little computational\neffort we would quickly run up against data retrieval bottlenecks. In cases like this, distributing\nthe effort horizontally means, with some infrastructure effort, on aggregate we have less idle time\nin the system. Another key feature of horizontal scaling in our case is the common availability of\nclusters at primarily undergraduate institutions. These primarily undergraduate institutions often\nhave no access to the large super computers available at large institutions.\n\nThe planning and design of infrastructure lead us to address the second challenge, space to store\ndata. We will touch on two points: first the actual storage of the data, and second, accessing and\nadding to the dataset. As we have discussed, knot and tangle data grows exponentially, as expected,\nthe space needed to store that data also grows exponentially. As a benchmark, we use arborescent\ntangles and the space required to store them in their linearized form (\n\nSection 6.2.4.1).\n\nTree Crossing Number\n\nProjected Total Number of Tangles up to TCN\n\nProjected Total Size of Notations up to TCN\n\n20\n\n20,178,846,455.0426\n\n744.93 GB\n\n21\n\n77,404,113,447.2751\n\n3.02 TB\n\n22\n\n296,920,571,662.606\n\n12.24 TB\n\n23\n\n1,138,987,289,416.26\n\n49.59 TB\n\n24\n\n4,369,161,597,793.56\n\n200.98 TB\n\n25\n\n16,760,135,017,593\n\n814.55 TB\n\n26\n\n64,292,004,387,526.9\n\n3.30 PB\n\n27\n\n246,624,621,285,968\n\n13.38 PB\n\n28\n\n946,053,943,972,148\n\n54.23 PB\n\n29\n\n3,629,070,212,865,634\n\n219.77 PB\n\nAs we can see, the space required for storing tangles quickly becomes large. For perspective, a\nbasic storage solution holds at least two copies of the data, meaning to store arborescent tangles\nup to 21 crossings, we need 3\\times4\\text{TB}=12\\text{TB} of disk space (using 4TB as it’s a\ncommon disk size). More robust would be a solution that allows for two drive failures such as\nRAIDZ2, in this case, we require \\LP2+3\\RP\\times4\\text{TB}=20\\text{TB}. At approximately \\$15\nper TB, putting us at around \\$200 for the basic solution and \\$300 for the robust solution.\nIt’s important to remember this is the required space and cost to store only a sequential list of\nnotations for tangles as in \n\nNote making retrieval of a specific tangle difficult.\n\nNote\n\n\\iota\\LP\\LP\\LB 2\\RB \\LB \\m 3\\RB \\RP1\\RP\\iota\\LP\\LP\\LB 2\\RB \\LB 2\\RB \\m 1\\RP1\\RP\\iota\\LP\\LP\\LB 2\\RB \\LB 2\\RB 1\\RP1\\RP\\cdots\n\nTo expand the list, we require infrastructure that allows for random access, the ability to search\nthe data, and the ability to add additional data. This will require that the data be stored in a\ndatabase system. Unfortunately, a database does come with a downside, it increases the storage\nrequirements for the data with mandatory overhead. With an effective data model and some\nconsideration of what should be stored and what should be computed on demand, we can mitigate some\nof this overhead. However, even at low crossing number \\leq 12, we will quickly run into storage\nissues as we complete undergraduate computation problems.\n\nWe will now discuss the selection and design of a database for a table of tangles. Our data will be\nused by undergraduates, so an ideal database system is one with a data model that has a shallow\nlearning curve. Additionally, our data is largely non-relational, meaning we don’t need a database\nsystem geared to relational data. These two items make a NoSQL database system ideal. Just as we had\noptions for vertical scaling and horizontal scaling for carrying out the computations we have the\nsame two options for serving our database. However, in the service case our choice is significantly\nmore clear. Based on the size of our data if we select vertical scaling our cost for a server will\nbe in the \\$10k-\\$20k (not including storage cost) range and we may still end up with bottlenecks.\nTherefore, for our needs, horizontal scaling is ideal. In this case we can use a few low-cost cloud\nservers to store portions of the data, with a coordinator balancing load across the system. If we\nencounter a bottleneck, instead of buying a whole new expensive server, we simply add another\nlow-cost server to our system. This horizontal scaling concept is called sharding, a feature of\nMongoDB an ideal choice for our needs.\n\n prettier-ignore-start ","type":"content","url":"/future-work#infrastructure-of-a-tabulation-program","position":21},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl3","url":"/future-work#sec-selection-projects","position":22},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":" prettier-ignore-end \n\nIn this section we will provide a curated collection of undergraduate research problem statements.\nWe will also give a brief outline for each, contextualizing the problem and describing what phase of\nthe research experience program the problem may be appropriate for:\n\nLower Division Student: A lower division student is a student with little to no research or\nabstract math experience. A student at this level should be expected to have completed a college\nalgebra course and started a calculus sequence. For students with a computational background we\nshould expect the student to have started an introduction to programming course.\n\nIntermediate Student: An intermediate student is a student who has some exposure to abstract\nmath. This could take the form of solving a lower division problem. These students should be well\ninto a calculus sequence, having completed calculus II (advanced integration) or calculus III\n(vector calculus). For students with a computational background we should expect the student to\nhave completed an introduction to programming sequence and started a course on algorithms and\ndata structures.\n\nUpper Division Student: An upper division student is a student who can be expected to work\nsemi-independently. They have solved one or more intermediate student problems, have completed\nthe standard calculus sequence, and have begun abstract math courses. For students with a\ncomputational background we should expect the student to have completed a discrete methods\ncourse, ideally covering computational complexity theory.\n\nThe remainder of the section gives statements for problems appropriate for undergraduate research.\nThe problems in the list fall into five types: visualizations (\n\nSection 8.2.3.1), invariants\n(\n\nSection 8.2.3.2), notations (\n\nSection 8.2.3.3), generation (\n\nSection 8.2.3.4), and\npotpourri (\n\nSection 8.2.3.5). prettier-ignore-start ","type":"content","url":"/future-work#sec-selection-projects","position":23},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl4","url":"/future-work#sec-proj-visual","position":24},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":" prettier-ignore-end \n\nVisualization and spatial reasoning are critically important for work in knot theory. Problems of\nthe visualization type develop specific visualizations or general visualization tools for knots and\ntangles. prettier-ignore-start ","type":"content","url":"/future-work#sec-proj-visual","position":25},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Create Knot Mosaics: Lower Division Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl5","url":"/future-work#sec-proj-mosaic","position":26},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Create Knot Mosaics: Lower Division Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":" prettier-ignore-end ","type":"content","url":"/future-work#sec-proj-mosaic","position":27},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Create Knot Mosaics: Lower Division Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl6","url":"/future-work#problem-statement","position":28},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Create Knot Mosaics: Lower Division Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"Create a knot mosaic that has a particular property.","type":"content","url":"/future-work#problem-statement","position":29},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Brief","lvl5":"Create Knot Mosaics: Lower Division Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl6","url":"/future-work#brief","position":30},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Brief","lvl5":"Create Knot Mosaics: Lower Division Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"Knot mosaics are a simple method for creating knots from a collection of tiles. Creating mosaics\nwith a particular property, a specific writhe, for example, is a fun and engaging activity where\nabstraction of a concept can be explored. Modifying the tile set can add additional complexity to\nthe task. prettier-ignore-start ","type":"content","url":"/future-work#brief","position":31},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Create Stick Knots: Lower Division Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl5","url":"/future-work#sec-proj-sticks","position":32},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Create Stick Knots: Lower Division Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":" prettier-ignore-end ","type":"content","url":"/future-work#sec-proj-sticks","position":33},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Create Stick Knots: Lower Division Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl6","url":"/future-work#problem-statement-1","position":34},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Create Stick Knots: Lower Division Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"Create stick knots with desired properties.","type":"content","url":"/future-work#problem-statement-1","position":35},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Brief","lvl5":"Create Stick Knots: Lower Division Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl6","url":"/future-work#brief-1","position":36},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Brief","lvl5":"Create Stick Knots: Lower Division Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"Stick knots are knots built from a collection of unit sticks. Creating a physical model by hand or\nwith computer design and 3D printing develops spatial reasoning skills needed for work in higher\nknot theory. prettier-ignore-start ","type":"content","url":"/future-work#brief-1","position":37},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Creating Celtic Knots: Lower Division Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl5","url":"/future-work#sec-proj-quilt","position":38},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Creating Celtic Knots: Lower Division Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":" prettier-ignore-end ","type":"content","url":"/future-work#sec-proj-quilt","position":39},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Creating Celtic Knots: Lower Division Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl6","url":"/future-work#problem-statement-2","position":40},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Creating Celtic Knots: Lower Division Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"Create Celtic knots with desired properties.","type":"content","url":"/future-work#problem-statement-2","position":41},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Brief","lvl5":"Creating Celtic Knots: Lower Division Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl6","url":"/future-work#brief-2","position":42},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Brief","lvl5":"Creating Celtic Knots: Lower Division Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"Celtic knots are common artistic knots. Exploring the creation of a unique rule set for creating\nCeltic knots is an opportunity to develop a unique understanding of the diagrammatic nuances of knot\ntheory. prettier-ignore-start ","type":"content","url":"/future-work#brief-2","position":43},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Compute Diagram for General Notations: Intermediate Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl5","url":"/future-work#sec-proj-diagram-att","position":44},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Compute Diagram for General Notations: Intermediate Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":" prettier-ignore-end ","type":"content","url":"/future-work#sec-proj-diagram-att","position":45},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Compute Diagram for General Notations: Intermediate Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl6","url":"/future-work#problem-statement-3","position":46},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Compute Diagram for General Notations: Intermediate Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"Create an interface for plotting knots in an arbitrary notation in KnotPlot.","type":"content","url":"/future-work#problem-statement-3","position":47},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Brief","lvl5":"Compute Diagram for General Notations: Intermediate Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl6","url":"/future-work#brief-3","position":48},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Brief","lvl5":"Compute Diagram for General Notations: Intermediate Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"An aspect of knot theory that makes it among the most accessible higher math domains is the ability\nfor anyone to draw pictures of knots. A continuing theme of this thesis is that\ncomputations/operations are easy by hand, with the qualifier “up to reasonable crossing number”.\nThis carries through with the drawing of the diagrams. A common drawing tool in knot theory is\nKnotPlot \n\nScharein, 1998, unfortunately KnotPlot has no interface for\ndrawing knots in “arbitrary” notations. The tool however, does have a Lua scripting interface in\nwhich an arbitrary notation decoder can be designed.","type":"content","url":"/future-work#brief-3","position":49},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Create VR Band Plumbing Visualizer: Upper Division Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl5","url":"/future-work#create-vr-band-plumbing-visualizer-upper-division-student","position":50},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Create VR Band Plumbing Visualizer: Upper Division Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"","type":"content","url":"/future-work#create-vr-band-plumbing-visualizer-upper-division-student","position":51},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Create VR Band Plumbing Visualizer: Upper Division Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl6","url":"/future-work#problem-statement-4","position":52},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Create VR Band Plumbing Visualizer: Upper Division Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"Create a 3D VR visualizer for the band plumbing construction for arborescent knots.","type":"content","url":"/future-work#problem-statement-4","position":53},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Brief","lvl5":"Create VR Band Plumbing Visualizer: Upper Division Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl6","url":"/future-work#brief-4","position":54},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Brief","lvl5":"Create VR Band Plumbing Visualizer: Upper Division Student","lvl4":"Visualization","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"The plumbing construction for arborescent knots and tangles is easiest visualized in 3D. The ideal\nfor visualizing these objects is in VR, as this reduces the need for spatial reasoning. While the\ntheory exists for creating the objects, the linear algebra required makes this an upper division\nproblem. prettier-ignore-start ","type":"content","url":"/future-work#brief-4","position":55},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl4":"Invariants","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl4","url":"/future-work#sec-projs-invariants","position":56},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl4":"Invariants","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":" prettier-ignore-end \n\nOne way to build conjecture is by the analysis of patterns in data, these conjectures often lead to\nthe development of new theory. Problems in this section create the collections of data that can be\nused for developing those conjectures and theories. prettier-ignore-start ","type":"content","url":"/future-work#sec-projs-invariants","position":57},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Compute Polynomial From A Tangle Notation: Intermediate Student or Upper Division Student","lvl4":"Invariants","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl5","url":"/future-work#sec-proj-homflypt","position":58},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Compute Polynomial From A Tangle Notation: Intermediate Student or Upper Division Student","lvl4":"Invariants","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":" prettier-ignore-end ","type":"content","url":"/future-work#sec-proj-homflypt","position":59},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Compute Polynomial From A Tangle Notation: Intermediate Student or Upper Division Student","lvl4":"Invariants","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl6","url":"/future-work#problem-statement-5","position":60},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Compute Polynomial From A Tangle Notation: Intermediate Student or Upper Division Student","lvl4":"Invariants","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"Develop the theory needed for efficiently computing polynomials of tangles","type":"content","url":"/future-work#problem-statement-5","position":61},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Brief","lvl5":"Compute Polynomial From A Tangle Notation: Intermediate Student or Upper Division Student","lvl4":"Invariants","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl6","url":"/future-work#brief-5","position":62},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Brief","lvl5":"Compute Polynomial From A Tangle Notation: Intermediate Student or Upper Division Student","lvl4":"Invariants","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"One of the most important advancements in knot theory was the discovery of knot polynomials as a\nclass of knot invariants. As an example, one of the most powerful of these polynomials is the\nHOMFLYPT polynomial \n\nFreyd et al., 1985 constructed from the skein relations equation\n\n\nFigure 4.\\begin{aligned}\n    P\\LP\\text{unknot}\\RP&=1\\\\\n    \\ell P\\left(L_{+}\\right)+\\ell^{-1} P\\left(L_{-}\\right)+m\n    P\\left(L_0\\right)&=0\\\\\n  \\end{aligned}\n\nConveniently, the data needed to apply the skein relations is precisely the data encoded by RLITT,\nrelative crossing data.\n\n\n\nFigure 4:The skein\nrelation for the HOMFLYPT polynomial.  (Public domain, via\nWikimedia Commons \n\nPbroks13, 2008)\n\nDepending on the polynomial selected, the problem is appropriate for intermediate students or upper\ndivision students. When the polynomial has a developed tangle theory, the solution will have a well\ndefined start and end point and is appropriate for intermediate students. Otherwise, the full tangle\ntheory must be developed. This requires experience with the development of original abstract theory,\nmaking the problem appropriate for upper division students.","type":"content","url":"/future-work#brief-5","position":63},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Compute Finite Type Invariant From A Tangle Notation: Intermediate Student or Upper Division Student","lvl4":"Invariants","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl5","url":"/future-work#compute-finite-type-invariant-from-a-tangle-notation-intermediate-student-or-upper-division-student","position":64},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Compute Finite Type Invariant From A Tangle Notation: Intermediate Student or Upper Division Student","lvl4":"Invariants","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"","type":"content","url":"/future-work#compute-finite-type-invariant-from-a-tangle-notation-intermediate-student-or-upper-division-student","position":65},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Compute Finite Type Invariant From A Tangle Notation: Intermediate Student or Upper Division Student","lvl4":"Invariants","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl6","url":"/future-work#problem-statement-6","position":66},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Compute Finite Type Invariant From A Tangle Notation: Intermediate Student or Upper Division Student","lvl4":"Invariants","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"Develop the theory needed for efficiently computing a finite type invariant of tangles","type":"content","url":"/future-work#problem-statement-6","position":67},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Brief","lvl5":"Compute Finite Type Invariant From A Tangle Notation: Intermediate Student or Upper Division Student","lvl4":"Invariants","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl6","url":"/future-work#brief-6","position":68},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Brief","lvl5":"Compute Finite Type Invariant From A Tangle Notation: Intermediate Student or Upper Division Student","lvl4":"Invariants","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"Similar to the computation of polynomial invariants the computation of finite type invariants\nexpands our table with data useful for binning future tangles and knots. Depending on the invariant\nselected, the problem is appropriate for intermediate or upper division students. When the invariant\nhas a developed tangle theory the solution will have a well defined start and end point and be\nappropriate for intermediate students. Otherwise, the full tangle theory must be developed. This\nrequires experience with the development of original abstract theory, making the problem appropriate\nfor upper division students. prettier-ignore-start ","type":"content","url":"/future-work#brief-6","position":69},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl4":"Notations","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl4","url":"/future-work#sec-proj-notations","position":70},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl4":"Notations","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":" prettier-ignore-end \n\nThere are many ways to encode the data of a knot, each with advantages and disadvantages. Throughout\nthis thesis, the primary target notation was the RLITT \n\nSection 6.2.3. This subsection discusses\nseveral useful notations where a computational tool translating from and to RLITT is desired. Since\nthe source and destination notation in each problem are well understood each is appropriate for\nintermediate students. prettier-ignore-start ","type":"content","url":"/future-work#sec-proj-notations","position":71},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Notation Description for Extended Gauss Notation: Intermediate Student","lvl4":"Notations","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl5","url":"/future-work#sec-proj-note-gauss","position":72},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Notation Description for Extended Gauss Notation: Intermediate Student","lvl4":"Notations","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":" prettier-ignore-end ","type":"content","url":"/future-work#sec-proj-note-gauss","position":73},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Notation Description for Extended Gauss Notation: Intermediate Student","lvl4":"Notations","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl6","url":"/future-work#problem-statement-7","position":74},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Notation Description for Extended Gauss Notation: Intermediate Student","lvl4":"Notations","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"Develop the theory translating RLITT to extended Gauss notation. Additionally, develop the software\nneeded for storing and translating per theory.prettier-ignore-start","type":"content","url":"/future-work#problem-statement-7","position":75},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Notation Description for Planar Diagram (PD) Notation: Intermediate Student","lvl4":"Notations","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl5","url":"/future-work#sec-proj-note-pd","position":76},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Notation Description for Planar Diagram (PD) Notation: Intermediate Student","lvl4":"Notations","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"prettier-ignore-end","type":"content","url":"/future-work#sec-proj-note-pd","position":77},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Notation Description for Planar Diagram (PD) Notation: Intermediate Student","lvl4":"Notations","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl6","url":"/future-work#problem-statement-8","position":78},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Notation Description for Planar Diagram (PD) Notation: Intermediate Student","lvl4":"Notations","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"Develop the theory for translating RLITT to PD notation. Additionally, develop the software required\nfor storing and translating per theory.prettier-ignore-start","type":"content","url":"/future-work#problem-statement-8","position":79},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Notation Description for DT Notation: Intermediate Student","lvl4":"Notations","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl5","url":"/future-work#notation-description-for-dt-notation-intermediate-student","position":80},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Notation Description for DT Notation: Intermediate Student","lvl4":"Notations","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"prettier-ignore-end","type":"content","url":"/future-work#notation-description-for-dt-notation-intermediate-student","position":81},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Notation Description for DT Notation: Intermediate Student","lvl4":"Notations","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl6","url":"/future-work#problem-statement-9","position":82},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Notation Description for DT Notation: Intermediate Student","lvl4":"Notations","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"Develop the theory for translating RLITT to DT notation. Additionally, develop the software needed\nfor storing and translating per theory. prettier-ignore-start ","type":"content","url":"/future-work#problem-statement-9","position":83},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl4":"Generation","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl4","url":"/future-work#sec-proj-gen","position":84},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl4":"Generation","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":" prettier-ignore-end prettier-ignore-end\n\nThis section expands the census of tangles to more abstract classes. These expanded lists increase\naccessibility of complex objects allowing for the creation of new theory.","type":"content","url":"/future-work#sec-proj-gen","position":85},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Create a table of virtual tangles: Upper Division Student","lvl4":"Generation","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl5","url":"/future-work#create-a-table-of-virtual-tangles-upper-division-student","position":86},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Create a table of virtual tangles: Upper Division Student","lvl4":"Generation","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"","type":"content","url":"/future-work#create-a-table-of-virtual-tangles-upper-division-student","position":87},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Create a table of virtual tangles: Upper Division Student","lvl4":"Generation","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl6","url":"/future-work#problem-statement-10","position":88},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Create a table of virtual tangles: Upper Division Student","lvl4":"Generation","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"Create the theory needed to construct a table of virtual tangles.","type":"content","url":"/future-work#problem-statement-10","position":89},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Brief","lvl5":"Create a table of virtual tangles: Upper Division Student","lvl4":"Generation","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl6","url":"/future-work#brief-7","position":90},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Brief","lvl5":"Create a table of virtual tangles: Upper Division Student","lvl4":"Generation","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"Virtual knots, developed by Kauffman \n\nKauffman, 1999, are an extension of the knot\nconcept where a knot shadow need not be planar. Some work has been done on classifying the virtual\ntangles by Mellor and Nevin \n\nMellor & Nevin, 2020. The full tangle theory must be\ndeveloped to solve this problem. This requires experience with the development of original abstract\ntheory, making the problem appropriate for upper division students","type":"content","url":"/future-work#brief-7","position":91},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Create a table of n string tangles: Upper Division Student","lvl4":"Generation","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl5","url":"/future-work#create-a-table-of-n-string-tangles-upper-division-student","position":92},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Create a table of n string tangles: Upper Division Student","lvl4":"Generation","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"","type":"content","url":"/future-work#create-a-table-of-n-string-tangles-upper-division-student","position":93},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Create a table of n string tangles: Upper Division Student","lvl4":"Generation","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl6","url":"/future-work#problem-statement-11","position":94},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Create a table of n string tangles: Upper Division Student","lvl4":"Generation","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"Create the theory needed to construct a table of n string tangles.","type":"content","url":"/future-work#problem-statement-11","position":95},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Brief","lvl5":"Create a table of n string tangles: Upper Division Student","lvl4":"Generation","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl6","url":"/future-work#brief-8","position":96},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Brief","lvl5":"Create a table of n string tangles: Upper Division Student","lvl4":"Generation","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"The tangles we have worked with in this thesis are the two string tangles, those with four fixed\npoints on the Conway circle. A natural extension to this concept is the n string tangle. Recently,\nKwon \n\nKwon, 2025, the 3 strings rational tangles, have been\nclassified. For the remaining cases, the full tangle theory must be developed to solve the problem,\nthis requires experience with the development of original abstract theory, making the problem\nappropriate for upper division students prettier-ignore-start ","type":"content","url":"/future-work#brief-8","position":97},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl4":"Potpourri","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl4","url":"/future-work#sec-proj-pot","position":98},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl4":"Potpourri","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":" prettier-ignore-end \n\nProblems in this section are those that do not fit into other classes of problems. prettier-ignore-start ","type":"content","url":"/future-work#sec-proj-pot","position":99},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Random Tangle Sampling: Upper Division Student","lvl4":"Potpourri","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl5","url":"/future-work#sec-proj-rand","position":100},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Random Tangle Sampling: Upper Division Student","lvl4":"Potpourri","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":" prettier-ignore-end ","type":"content","url":"/future-work#sec-proj-rand","position":101},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Random Tangle Sampling: Upper Division Student","lvl4":"Potpourri","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl6","url":"/future-work#problem-statement-12","position":102},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Random Tangle Sampling: Upper Division Student","lvl4":"Potpourri","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"Create the theory and software to select from a collection or generate a tangle at random with an\nunderstood distribution.","type":"content","url":"/future-work#problem-statement-12","position":103},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Brief","lvl5":"Random Tangle Sampling: Upper Division Student","lvl4":"Potpourri","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl6","url":"/future-work#brief-9","position":104},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Brief","lvl5":"Random Tangle Sampling: Upper Division Student","lvl4":"Potpourri","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"In the introduction chapter \n\nSection 4.2, applications of knots to the hard sciences were\ndiscussed. When working in the hard sciences, being able to sample with an understood distribution\nfrom a collection is important. Similarly to the previous notational projects, describing and\nimplementing random sampling methodologies is a class of extremely useful tabulation projects. The\nfull tangle theory must be developed to solve this problem. This requires experience with the\ndevelopment of original abstract theory, making the problem appropriate for upper division students","type":"content","url":"/future-work#brief-9","position":105},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Develop a tangle analogue for petal knots: Upper Division Student","lvl4":"Potpourri","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl5","url":"/future-work#develop-a-tangle-analogue-for-petal-knots-upper-division-student","position":106},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl5":"Develop a tangle analogue for petal knots: Upper Division Student","lvl4":"Potpourri","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"","type":"content","url":"/future-work#develop-a-tangle-analogue-for-petal-knots-upper-division-student","position":107},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Develop a tangle analogue for petal knots: Upper Division Student","lvl4":"Potpourri","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl6","url":"/future-work#problem-statement-13","position":108},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Problem Statement","lvl5":"Develop a tangle analogue for petal knots: Upper Division Student","lvl4":"Potpourri","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"Create the theory needed for a well defined tangle analogue of the petal\nknots\n\nAdams et al., 2015.","type":"content","url":"/future-work#problem-statement-13","position":109},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Brief","lvl5":"Develop a tangle analogue for petal knots: Upper Division Student","lvl4":"Potpourri","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"type":"lvl6","url":"/future-work#brief-10","position":110},{"hierarchy":{"lvl1":"Future Directions and Undergraduate Research","lvl6":"Brief","lvl5":"Develop a tangle analogue for petal knots: Upper Division Student","lvl4":"Potpourri","lvl3":"Selection of Undergraduate Projects","lvl2":"Tabulation as Undergraduate Research"},"content":"Petal knots, first developed by Adams \n\nAdams et al., 2015, are knots in which all\ncrossings are collinear in the orthogonal projection, an “ubercrossing”. Converting these objects to\na braid is straightforward, however less obvious is converting to a two string tangle. Identifying a\ntangle analogue for the petal knots may allow for computation of a whole new family of tangle data.\nThe full tangle theory must be developed to solve this problem. This requires experience with the\ndevelopment of original abstract theory, making the problem appropriate for upper division students\n\nDefinition: A miscellaneous collection\n\nA stick knot is a knot made of straight lines of a unit length.","type":"content","url":"/future-work#brief-10","position":111},{"hierarchy":{"lvl1":"Introduction"},"type":"lvl1","url":"/introduction","position":0},{"hierarchy":{"lvl1":"Introduction"},"content":"There exists a common view of advanced mathematics as esoteric nonsense only understandable by elite\nthinkers. While that sentiment is perhaps deserved by some mathematical disciplines, knot theory is\nan area of advanced mathematics that offers deep significance as well as general accessibility. A\nlay person can be easily taught the basic structures of knot theory, while it takes years to master\nthe details.\n\n prettier-ignore-start ","type":"content","url":"/introduction","position":1},{"hierarchy":{"lvl1":"Introduction","lvl2":"An Intuitive Grounding in Knot Theory"},"type":"lvl2","url":"/introduction#sec-intro-intuit-knot-theory","position":2},{"hierarchy":{"lvl1":"Introduction","lvl2":"An Intuitive Grounding in Knot Theory"},"content":" prettier-ignore-end \n\nA knot, when used in everyday life, is a tool whether it’s the “bunny ear” knot holding on your\nshoe, a decorative monkey’s fist on your key chain, or a climbing hitch securing yourself to a rock\nwall. Now, when thinking of these tool knots, we should note one critical attribute, they’re made of\na single string with open ends (\n\nFigure 1). Notice with this construction, no matter\nhow “knotted” the string, we can always pull on loops to remove the knot, leaving us with only an\nunknotted string.\n\n\n\nFigure 1:An everyday knot with open ends.\n\nThis leaves us with a somewhat unsatisfying construction, exactly one object, a string. How might we\nadd some spice to our construction? What if we turn the string into a circle by gluing the ends as\nin \n\nFigure 2? When we try to wiggle the closed up string around, trying to\nremove the knot, we stretch and pull on the string, but regardless of what we do, we end up with a\nknot. Constructing a physical model of \n\nFigure 2 and playing with it should\nconvince you that the knot can’t be removed. We call these closed up versions of knots\nmathematical knots.\n\n\n\nFigure 2:Closing the ends of the everyday knot in \n\nFigure 1 to form a\nmathematical knot.\n\nWith this, when compared to an everyday knot, we are already in a better place. Continue to\nexperiment with your physical model by twisting the ends of the string around each other in\ndifferent ways (\n\nFigure 4). You may discover that gluing the ends yields knots that can’t be\nmaneuvered to look the same as \n\nFigure 2 or \n\nFigure 3.\n\n\n\nFigure 3:A representation of a simple loop made from gluing the ends of a rope together.\n\n\n\nFigure 4:A representation of twisting the ends of a rope around itself before gluing.\n\nIn fact, this twisting gives us a whole infinite family of odd crossing torus knots, a sampling of\nwhich can be seen in \n\nFigure 5. A good exercise in building intuition is to convince\nyourself that the torus knots in \n\nFigure 5 are different from each other.\n\n\n\nFigure 5:Three knots built from the operation seen in \n\nFigure 4. From left\nto right: three, five, and seven crossing torus knots.\n\nOur experimentation with the physical model may conjure some questions, three important questions we\nmay ask are:\n\n“How do I systematically construct knots?”\n\n“How do I tell two knots I make apart?”\n\n“How do I generate new knots?”\n\nAttempting to answer these questions, even just in part or with restrictions, is the bread and\nbutter of knot theory and the focus of the rest of this thesis. Some great texts for continued\nreading on knot theory in order of accessibility are: The Knot Book: An Elementary Introduction to\nthe Mathematical Theory of Knots by Adams \n\nAdams, 2004, LinKnot: Knot Theory by\nComputer by Jablan and Sazdanović \n\nJablan & Sazdanović, 2007, Knots and Links by Rolfsen\n\n\nRolfsen, 2003, and An Introduction to Knot Theory by Lickerish\n\n\nLickorish, 1997.\n\nThe remainder of this thesis quickly exchanges the idea of a knot for that of a tangle, introduced\nby Conway \n\nConway, 1970. A tangle can be thought of as slamming a cookie cutter\nonto a knot diagram pinning down four points. Once the knot is pinned down we then cut off the parts\nof the knot lying outside the cookie cutter, seen in \n\nFigure 6.\n\n\n\nFigure 6:The creation of a tangle from a knot by cutting a section out of the knot but\nfixing four points.\n\n prettier-ignore-start ","type":"content","url":"/introduction#sec-intro-intuit-knot-theory","position":3},{"hierarchy":{"lvl1":"Introduction","lvl2":"Brief Discussion on Applications"},"type":"lvl2","url":"/introduction#sec-intro-applications","position":4},{"hierarchy":{"lvl1":"Introduction","lvl2":"Brief Discussion on Applications"},"content":" prettier-ignore-end \n\nAs we saw in \n\nSection 4.1, mathematical knots can be easily constructed as physical\nobjects. It should be no surprise then that mathematical knots and tangles appear in the hard\nsciences, particularly in the realms of physics, chemistry, and biology. In this section, we will\ndiscuss one of the most commonly discussed applications of knot theory.","type":"content","url":"/introduction#sec-intro-applications","position":5},{"hierarchy":{"lvl1":"Introduction","lvl3":"Tangles in DNA","lvl2":"Brief Discussion on Applications"},"type":"lvl3","url":"/introduction#tangles-in-dna","position":6},{"hierarchy":{"lvl1":"Introduction","lvl3":"Tangles in DNA","lvl2":"Brief Discussion on Applications"},"content":"One of the fundamental features that identifies life as life is the ability to self-replicate. In\norder to self-replicate, life must have a mechanism to pass information to successive generations.\nConsider first the most basic self replicating component of life, called a cell. The information of\na cell is stored as double-stranded DNA (dsDNA), as described by Crick, Franklin, Gosling, and\nWatson \n\nWatson & Crick, 1953\n\nFranklin & Gosling, 1953, a polymer\nconsisting of two strands constructed from a sugar-phosphate connected to one of the monomers\n\n\nWatson & Crick, 1953:\n\nAdenine (A)\n\nGuanine (G)\n\nCytosine (C)\n\nThymine (T)\n\n\n\nFigure 7:A schematic diagram demonstrating the structure of a dsDNA polymer (Ball CC BY-SA 2.5 via Wikimedia\nCommons \n\nPrice Ball, 2007)\n\nThe two strands of dsDNA connect to each other to form the “double-helix” where the monomers bind to\neach other with guanine (G) binding to cytosine (C) and adenine (A) binding to thymine (T)\n\n\nWatson & Crick, 1953 (\n\nFigure 7). When replicating, the\ncell will duplicate the dsDNA by splitting the dsDNA into two single strands with the enzyme DNA\nhelicase. Once the DNA is split, two new complementary single strands are constructed to be paired\nwith each of the original single strands.\n\n\n\nFigure 8:A schematic diagram demonstrating the splitting of a double strand of DNA into\ntwo new double strands. (Ruiz Public domain via Wikimedia\nCommons\n\nRuiz, n.d.)\n\nThe dsDNA of a cell needs to be physically stored inside the cell. Cell volume is limited, so\norganizing the dsDNA to fit in that volume requires several complex cellular mechanisms. One issue\nsolved by these mechanisms is that of local knotting, which becomes a problem when the cell attempts\nto replicate. During the replication process, the DNA helicase begins splitting the dsDNA, but when\nthe DNA helicase reaches the locally knotted portion, it becomes stuck, the replication will be\nunable to continue \n\nAlberts et al., 2022, and the cell will die. If this local knotting\nis allowed to happen unchecked, every cell would eventually be unable to replicate and would\nultimately die. Famously, life finds a way, and one cellular mechanism that mitigates this local\nknotting problem is the enzyme type II topoisomerase \n\nAlberts et al., 2022.\n\n\n\nFigure 9:A schematic diagram of the enzyme type II topoisomerase. (Sutor CC BY-SA 4.0 via Wikimedia\nCommons \n\nSutor, n.d.)\n\nThe enzyme attempts to solve this local knotting by cutting one of the dsDNA where two segments\ncross, then moving the top double strand to the bottom, this action can be seen in \n\nFigure 10.\n\n\n\nFigure 10:Type II topoisomerase doing a crossing exchange. From top left to bottom\nright: 1) A crossing of two dsDNA segments. 2) The enzyme grabs the under segment.\n3) The enzyme splits the under segment. 4) The enzyme passes the over segments\nthrough the gap. 5) The crossing with the segments exchanged.\n\nIn mammals (and many other animal groups), dsDNA takes the form of long strings, which can only\nbecome everyday knots. However, it was discovered by Dulbecco and Vogt\n\n\nDulbecco & Vogt, 1963\n\nWeil & Vinograd, 1963\n\nVinograd et al., 1965\nthat in some viruses (Polyoma) the dsDNA is a closed loop, allowing it to form into a mathematical\nknot (\n\nFigure 11) .\n\n\n\n(a)A schematic diagram of circular dsDNA.\n\n\n\n(b)A scanning electron microscope image of knotted dsDNA (Arsuaga CC\nBY-ND \n\nArsuaga, 2013).\n\nFigure 11:Schematic diagrams of circular and knotted dsDNA.\n\nFrom here one may ask, “If the dsDNA is knotted and type II topoisomerase makes a change, what kind\nof new knot can this make?”, this question was addressed first by Ernst and Sumners in the 1990s\n\n\nErnst & Sumners, 1990 \n\nErnst, 1996. Their approach considers the dsDNA\nto be bounded by two “areas”, the first area is created by drawing a circle around the crossing that\ntype II topoisomerase is working on (right side of \n\nFigure 12a), and the second\nby drawing a circle around the remainder (left side of \n\nFigure 12a). From here,\nthe crossing change from type II topoisomerase can be modeled by changing the tangle bound in the\narea on the right (\n\nFigure 12), \n\nDarcy et al., 2008.\n\nNote\n\nAfter the change, there may be many crossings that type II topoisomerase could “choose” to work on next. A program\nlike TopoICE-X \n\nDarcy et al., 2008 (built into KnotPlot\n\n\nScharein, 1998) can help visualize the results of\nmaking these choices.\n\n\n\n(a)A knot diagram showing two areas containing knot data. The right side contains\nthe crossing that type II topoisomerase will work on.\n\n\n\n(b)A knot diagram showing two areas containing knot data. The right side contains\nthe crossing that type II topoisomerase has worked on.\n\nFigure 12:A tangle model for a crossing change in a knot.\n\nThe modeling of the action of type II topoisomerase is just one of the many applications for the\ntheory of knots and tangles found in biology. For further reading on applications, a good source is\nthe “Encyclopedia of knot theory”\n\nAdams, 2021, a survey of many subdisciplines\nof knot theory with a chapter devoted to applications.\n\n prettier-ignore-start ","type":"content","url":"/introduction#tangles-in-dna","position":7},{"hierarchy":{"lvl1":"Introduction","lvl2":"Overview of this Thesis"},"type":"lvl2","url":"/introduction#sec-intro-overview","position":8},{"hierarchy":{"lvl1":"Introduction","lvl2":"Overview of this Thesis"},"content":" prettier-ignore-end \n\nAs discussed in the previous section, the goal of this thesis is to address, in part, the three\nquestions “How do I systematically construct knots?”, “How do I tell two knots I make apart?”, and\n“How do I generate new knots?” Particularly, we will address a restricted version of these\nquestions, for objects that can be thought of as the building blocks of knots, the tangles\nintroduced by Conway \n\nConway, 1970. Through the middle of this thesis\n(\n\nChapter 6 Tabulation), we will describe several strategies that have\nbeen employed to answer even further restricted versions of these questions:\n\n“How do I systematically construct rational tangles?”, “How do I tell two rational tangles I make\napart?”, and “How do I generate new rational tangles?”\n\n“How do I systematically construct Montesinos tangles?” and “How do I tell two Montesinos tangles\nI make apart?”, and “How do I generate new Montesinos tangles?”\n\n“How do I systematically construct algebraic/arborescent tangles?” and “How do I tell two\nalgebraic/arborescent tangles I make apart?”, and “How do I generate new algebraic/arborescent\ntangles?”\n\nWhile we could answer these questions about tangles with pen and paper brute force as Tait, Little,\nKirkman, Conway, and Caudron \n\nTait, 1885\n\nKirkman, 1885\n\nLittle, 1885\n\nConway, 1970\n\nCaudron, 1982 did for knots. Beyond a reasonable\n“crossing number” (\n\nSection 5.2.1), as small as 8, the time and effort needed makes pen and paper\nuntenable. To achieve our goal in a reasonable time, we will follow a similar framework to that of\nHoste, Thistlethwaite, Weeks, and Burton \n\nHoste et al., 1998\n\nHoste, 2005\n\nBurton, 2020. Utilizing computer methods to\ngenerate a tangle table of algebraic/arborescent tangles to twelve crossings. To effectively utilize\ncomputers for this tabulation work requires the design and implementation of a knot theory specific\nsoftware toolbox.","type":"content","url":"/introduction#sec-intro-overview","position":9},{"hierarchy":{"lvl1":"Introduction","lvl3":"Chapter Summary","lvl2":"Overview of this Thesis"},"type":"lvl3","url":"/introduction#chapter-summary","position":10},{"hierarchy":{"lvl1":"Introduction","lvl3":"Chapter Summary","lvl2":"Overview of this Thesis"},"content":"We will now summarize each of the chapters of this thesis. Organizationally, this thesis is\npartitioned into five chapters, with each chapter further divided into sections and subsections.","type":"content","url":"/introduction#chapter-summary","position":11},{"hierarchy":{"lvl1":"Introduction","lvl4":"Chapter 1: Introduction","lvl3":"Chapter Summary","lvl2":"Overview of this Thesis"},"type":"lvl4","url":"/introduction#chapter-1-introduction","position":12},{"hierarchy":{"lvl1":"Introduction","lvl4":"Chapter 1: Introduction","lvl3":"Chapter Summary","lvl2":"Overview of this Thesis"},"content":"This introduction gave an intuitive description of the basics of knot theory and a discussion of an\napplication for knots and tangles. We now finish with this description of the content in the\nremainder of this thesis.","type":"content","url":"/introduction#chapter-1-introduction","position":13},{"hierarchy":{"lvl1":"Introduction","lvl4":"Chapter 2: Preliminaries","lvl3":"Chapter Summary","lvl2":"Overview of this Thesis"},"type":"lvl4","url":"/introduction#chapter-2-preliminaries","position":14},{"hierarchy":{"lvl1":"Introduction","lvl4":"Chapter 2: Preliminaries","lvl3":"Chapter Summary","lvl2":"Overview of this Thesis"},"content":"This chapter gives the preliminaries in knot and tangle theory needed for the rest of the thesis.\nIncluded are the historical background of tabulation in knot theory and a grounding in knot and\ntangle theory. We will see definitions for knots and tangles, as well as some notations and\ninvariants for those knots and tangles.","type":"content","url":"/introduction#chapter-2-preliminaries","position":15},{"hierarchy":{"lvl1":"Introduction","lvl4":"Chapter 3: Tabulation","lvl3":"Chapter Summary","lvl2":"Overview of this Thesis"},"type":"lvl4","url":"/introduction#chapter-3-tabulation","position":16},{"hierarchy":{"lvl1":"Introduction","lvl4":"Chapter 3: Tabulation","lvl3":"Chapter Summary","lvl2":"Overview of this Thesis"},"content":"This chapter describes the theoretical methodology for the tabulation of algebraic tangles. It is\ndivided into two sections, the first contains the method used for tabulation of two well-understood\nclasses of tangles: the rational and Montesinos tangles. The second describes the methodology for\nthe tabulation of the more general type of tangle the arborescent (algebraic) tangles. For each\nclass of tangle we tabulated, a definition and classification is given, followed by a theoretical\ngeneration strategy.","type":"content","url":"/introduction#chapter-3-tabulation","position":17},{"hierarchy":{"lvl1":"Introduction","lvl4":"Chapter 4: Software and Its Engineering","lvl3":"Chapter Summary","lvl2":"Overview of this Thesis"},"type":"lvl4","url":"/introduction#chapter-4-software-and-its-engineering","position":18},{"hierarchy":{"lvl1":"Introduction","lvl4":"Chapter 4: Software and Its Engineering","lvl3":"Chapter Summary","lvl2":"Overview of this Thesis"},"content":"This chapter addresses the computational and engineering aspects of software for mathematics\nresearch. The chapter begins with an overview of product management and software engineering\npractices. In our discussion of software engineering we develop a process designed for use by\nprofessional and undergraduate researchers in computational knot theory. With our process, we create\na product design for a general purpose “knot theory software toolbox”. The chapter concludes with\nthe software design (unit description) for the tools developed to realize the solutions in the\ntabulation section.","type":"content","url":"/introduction#chapter-4-software-and-its-engineering","position":19},{"hierarchy":{"lvl1":"Introduction","lvl4":"Chapter 5: Future Directions","lvl3":"Chapter Summary","lvl2":"Overview of this Thesis"},"type":"lvl4","url":"/introduction#chapter-5-future-directions","position":20},{"hierarchy":{"lvl1":"Introduction","lvl4":"Chapter 5: Future Directions","lvl3":"Chapter Summary","lvl2":"Overview of this Thesis"},"content":"The final chapter of this thesis gives an overview of future work to be done in the tangle\ntabulation domain. This takes two forms, first the direct next steps for tangle tabulation at the\nprofessional research level. Second, we outline a collection of topics and research directions at\nvarious levels appropriate for undergraduate researchers.","type":"content","url":"/introduction#chapter-5-future-directions","position":21},{"hierarchy":{"lvl1":"Preliminaries"},"type":"lvl1","url":"/background","position":0},{"hierarchy":{"lvl1":"Preliminaries"},"content":" prettier-ignore-start ","type":"content","url":"/background","position":1},{"hierarchy":{"lvl1":"Preliminaries","lvl2":"History of Knot Tabulation"},"type":"lvl2","url":"/background#sec-history-of-tabulation","position":2},{"hierarchy":{"lvl1":"Preliminaries","lvl2":"History of Knot Tabulation"},"content":" prettier-ignore-end \n\nMathematical interest in knots was brought to the forefront of mathematics and physics during the\n1860s by Lord Kelvin. A central area of research in physics during the 1860s was the investigation\nof the fundamental building blocks of matter: the atoms. Lord Kelvin hypothesized that atoms were\nknotted vortices in the aether \n\nThomson, 1867. With this hypothesis, a natural next step\nis the creation of a table of the elements which, by hypothesis, was a table of knots.","type":"content","url":"/background#sec-history-of-tabulation","position":3},{"hierarchy":{"lvl1":"Preliminaries","lvl3":"Knot Tabulation by Hand","lvl2":"History of Knot Tabulation"},"type":"lvl3","url":"/background#knot-tabulation-by-hand","position":4},{"hierarchy":{"lvl1":"Preliminaries","lvl3":"Knot Tabulation by Hand","lvl2":"History of Knot Tabulation"},"content":"With Lord Kelvin’s vortex hypothesis as the driving force for knot tabulation, the first knot table\nwas produced, via hand computation, by P.G. Tait. Tait’s first table, completed in the 1860s,\ncontained prime knots (described in \n\nSection 5.2.3) up to seven crossings\n\n\nTait, 1884, a table of the first seven knots can be seen in \n\nFigure 1\n\n\n\nFigure 1:A table of the first seven prime knots. \n\nScharein, 1998\n\nWith a table of seven crossing knots complete, Tait’s work in knot tabulation continued, alongside\nKirkman and Little \n\nTait, 1885\n\nKirkman, 1885\n\nLittle, 1885, for the next 25 years. The trio ultimately constructed a complete list\nof prime knots up to ten crossings (250 knots + 1 repeat). When the knot theoretic machinery\navailable at the time is considered, the completion of these tables with such high accuracy was a\nHerculean task. The tables contained a single error, two equivalent (described in\n\n\nSection 5.2.2) ten crossing knots (\n\nFigure 2), identified in 1974 by Perko, an\namateur mathematician \n\nPerko, 1974.\n\n\n\nFigure 2:The Perko pair, a pair of equivalent ten crossing knots appearing as an\nerror in early knot tables\n\n\nScharein, 1998\n\nPerko, 1974.\n\nAfter the completion of the ten crossing tables, efforts in knot tabulation stagnated, with few\nconcerted efforts and little progress being made in expanding the tables. The next researcher to\ntake up the tabulation torch was Conway in the 1960s \n\nConway, 1970. Conway, in\n“a few hours” \n\nConway, 1970, tabulated knots to eleven crossings, with only\nfour omissions\n\nCaudron, 1982. Conway’s work continued by hand computation but employed\na novel approach to tabulation. He described decompositions of knots into building blocks, which he\ncalled tangles\n\nConway, 1970. Conway paired this with a calculus to glue the\nblocks together. Under Conway’s tangle calculus, the combinatorial work of knot tabulation became a\ngame of building from simple to complex. Inspired by Conway’s strategies, a second effort to\nenumerate eleven crossing knots was carried out by Caudron \n\nCaudron, 1982, verifying\nConway’s findings and rectifying the four omissions. Caudron’s confirmation of the eleven crossing\ntables marked the final chapter in the hand computation era of knot tabulation.","type":"content","url":"/background#knot-tabulation-by-hand","position":5},{"hierarchy":{"lvl1":"Preliminaries","lvl3":"Knot Tabulation by Computer","lvl2":"History of Knot Tabulation"},"type":"lvl3","url":"/background#knot-tabulation-by-computer","position":6},{"hierarchy":{"lvl1":"Preliminaries","lvl3":"Knot Tabulation by Computer","lvl2":"History of Knot Tabulation"},"content":"With advancements in manufacturing in the early 1980s, electronic computers became closer to\ncommodity products. This allowed for researchers of diverse backgrounds and interests to take their\ncrack at time-consuming computational tasks. One of these computational tasks was the construction\nof knot tables. The first to construct a knot table by computer were Dowker and Thistlethwaite in\n1983 \n\nDowker & Thistlethwaite, 1983, who produced a table of all prime knots to thirteen\ncrossings. The pair implemented a novel two pass approach that has served as an outline for all\nmajor efforts that have followed. The process begins with a first pass to enumerate all possible\nknot diagrams (described in \n\nSection 5.2.1). This is followed by a second pass where “sufficient\ninvariants to distinguish them (knots) from each other” \n\nDowker & Thistlethwaite, 1983\nare computed. This effectively assigns knots to equivalence classes (bins ), hence finding\nand removing all duplicate entries from the list (deduping ).\n\nThe next table produced by computer, knots up to sixteen crossing, was given by Hoste,\nThistlethwaite, and Weeks \n\nHoste et al., 1998 in 1998. Their process deviates only\nslightly from the earlier approach of Dowker and Thistlethwaite by leaning on\nheuristics to limit the duplicates found in their first pass. This preprocessing in the\nfirst pass allowed Hoste, Thistlethwaite, and Weeks to compute their table in one to two weeks of\nwall time.\n\nThe most recent computational effort was carried out by Burton in 2020 \n\nBurton, 2020,\nfinding knots to nineteen crossings. Burton’s program closely followed the two pass process, with\nfurther heuristic work to preprocess in the first pass and heavily relying on the hyperbolic volume\ninvariant for the second pass. The computation of the nineteen crossing table required months of\nwall time on a cluster, serving as an important signpost for the time requirement problems\nof knot tabulation.","type":"content","url":"/background#knot-tabulation-by-computer","position":7},{"hierarchy":{"lvl1":"Preliminaries","lvl3":"Tangle Tabulation","lvl2":"History of Knot Tabulation"},"type":"lvl3","url":"/background#tangle-tabulation","position":8},{"hierarchy":{"lvl1":"Preliminaries","lvl3":"Tangle Tabulation","lvl2":"History of Knot Tabulation"},"content":"Conway’s tangle construction allowed him to quickly and effectively tabulate knots by hand. These\nbuilding blocks of knots are interesting mathematical objects in their own right, however tabulation\nefforts for tangles have been sparse. The importance of the creation of a large table of tangles has\nbeen called:\n\n“The Most Important Missing Infrastructure Project in Knot Theory” - Bar-Natan\n\n\nBar-Natan, n.d.\n\nAs it stands, tables of tangles have been generated by hand up to seven crossings by Kanenobu,\nSaito, and Satoh \n\nKanenobu et al., 2003. Computer driven efforts have been undertaken\nby several members of the University of Iowa Applied Topology (UIAT) group namely Conolly\n\n\nConnolly, 2021, Bryhtan \n\nBryhtan, 2024, and\nthis thesis. Separately, a table of algebraic tangles has been produced by Gren, Sulkowska, and,\nGabrovšek\n\nGren et al., 2025. Their tabulation is built on a binary operation\ntree based on Conway’s \n\nConway, 1970 tangle calculus. Similar binary operation\ntrees can be seen in Conolly \n\nConnolly, 2021, Caudron\n\n\nCaudron, 1982, and discussed in (#sec-monttang).\n\nIn software development, the mathematical concept of an equivalence class is often called a\n``bin’'.\n\nShort for deduplicating, meaning the removal of duplicate entries from the list.\n\nWhen discussing algorithms, a heuristic describes a special case that, when seen, short circuits\nthe algorithm, reducing unnecessary work.\n\nThe real effective time of a clock on a wall, this is different from CPU time which is a\nrelative measure of time.\n\nAn aggregation of many computers, each with many computational cores. We’ll see later in this\nthesis that tabulation is massively parallelizable.\n\n","type":"content","url":"/background#tangle-tabulation","position":9},{"hierarchy":{"lvl1":"Preliminaries","lvl2":"Foundations of Knots"},"type":"lvl2","url":"/background#foundations-of-knots","position":10},{"hierarchy":{"lvl1":"Preliminaries","lvl2":"Foundations of Knots"},"content":"We now begin a more formal description of the foundations of the theory of knots. Our treatment will\nbegin with the general definition of knots, as well as similar knot-like objects. Next, we will\ndiscuss ways in which two knots can be considered equivalent. With this, we’ll give an example of a\ncommon invariant for knots. Finally, we conclude with descriptions of the notational strategy that\ninspired the rest of this thesis, the Conway notation.\n\n prettier-ignore-start ","type":"content","url":"/background#foundations-of-knots","position":11},{"hierarchy":{"lvl1":"Preliminaries","lvl3":"Definition of a Knot","lvl2":"Foundations of Knots"},"type":"lvl3","url":"/background#subsec-knot-def","position":12},{"hierarchy":{"lvl1":"Preliminaries","lvl3":"Definition of a Knot","lvl2":"Foundations of Knots"},"content":" prettier-ignore-end \n\nAs with anything, we must start with a definition, here we give one for a proper knot.\n\nJablan and Sazdanović Definition 1.17 \n\nJablan & Sazdanović, 2007\n\nA proper knot is a smooth embedding of a circle  S^1 into Euclidean\n3-dimensional space \\R^3 (or the 3-dimensional sphere\nS^3).\n\nWith some consideration, we can see this definition aligns with our intuitive description of a knot\ngiven in \n\nSection 4.1. We note that this definition gives two choices for ambient\nspace, for this thesis we will prefer S^3 as an ambient space, the preference will become clear in\nlater sections. A natural extension of the concept of a knot is to allow for more than a single\nS^1 component to be embedded into the ambient space. This allowance gives us the concept of a\nc component link.\n\nJablan and Sazdanović Definition 1.17 \n\nJablan & Sazdanović, 2007\n\nA c component link is a smooth embedding of  c disjoint copies of a circle\nS^1 into \\R^3 (or S^3), where the embeddings of circles S_i^1 are its\ncomponents (i = 1, 2,\\dots, c).\n\nFor convenience and brevity, in the remainder of this thesis we\nwill adopt the\nfollowing convention. The term knot refers to the collection of\nall proper knots and\nall c component links. If we find the need to exclude the c\ncomponent links\nfrom consideration, we will use the term proper knot.\n\nPlaying with this three-dimensional construction for knots, it will quickly become apparent that\nthree-dimensional knots are unwieldy to work with. To simplify our work, we will now build a\ntwo-dimensionally encoded model for knots, a knot diagram. We start by taking a knot\nK\\subset S^3. We then select a S^2 such that K lies fully in the interior. Now, for any plane\nthat lies tangent to S^2, we take an orthogonal projection of the knot onto the plane. We require\nthat the projection have no degenerate crossings, intersections of the knot projection where\nmore than two points are collinear or where the crossing is not transverse. We call this projection\na knot shadow, an example can be seen in \n\nFigure 3. A knot shadow is interpreted as a\nplanar graph, with points where strands overlap (are collinear in the projection) as\nvertices and edges of the shadow as the strands between the overlaps.\n\n\n\nFigure 3:A schematic diagram demonstrating a knot (orange) and its\nshadow (grey).\nImagine a light shining from above the knot onto a piece of paper. The knot\nshadow is the shadow cast on the paper.\n\nTaking only the shadow of a knot we lose some data that is intuitively important, the crossings of a\nknot (the relative distance of collinear points). To recover this data in a diagram, we split the\nedges of the shadow where the strand closer to the projection plane appears to travel under the edge\ncorresponding to the strand further from the plane. We call the edge that is split the under\nstrand, and the non-split strand the over strand. These augmented knot shadows are called knot\ndiagrams and will serve as our primary schematic model for knots throughout this thesis. We call the\ncount of crossings in a knot diagram the crossing number of the knot diagram.\n\nWe finish with naming a knot with particular significance, the knot with no crossings in its diagram\nis called the unknot.\n\nA graph in the mathematical sense, a set of vertices combined with a set of relationships\nbetween those vertices called edges. A planar graph is a graph that when drawn in the plane has\nno overlapping edges.\n\n prettier-ignore-start ","type":"content","url":"/background#subsec-knot-def","position":13},{"hierarchy":{"lvl1":"Preliminaries","lvl3":"Knot Equivalence","lvl2":"Foundations of Knots"},"type":"lvl3","url":"/background#subsec-knot-equivalence","position":14},{"hierarchy":{"lvl1":"Preliminaries","lvl3":"Knot Equivalence","lvl2":"Foundations of Knots"},"content":" prettier-ignore-end \n\nArmed with the formal definition of a knot, we can make our first progress in answering the\noverarching question from \n\nSection 4.1.\n\nHow do I tell two knots I make apart?\n\nTo tell two knots apart, we need to discuss the concept of sameness, that is, what is equivalence in\nknots. Our concept of equivalence for knots is given by ambient isotopy, and equal knots are\nsaid to be ambient isotopic.\n\nJablan and Sazdanović, Definition 1.20 \n\nJablan & Sazdanović, 2007\n\nGordon & Luecke, n.d.\n\nKnots K and K_1 are ambient isotopic if there exists a\ncontinuous function H: \\R^3 \\times[0,1] \\rightarrow \\R^3 such that:\n\nh_0=H((x, y, z), 0) is the identity \\R^3 \\rightarrow \\R^3\n\nFor all t \\in[0,1], h_t=H((x, y, z), t) is a homeomorphism \\R^3 \\rightarrow \\R^3\n\nIf h_1=H((x, y, z), 1), then h_1(K)=K_1\n\nWhen working with the three-dimensional model of a knot, writing down explicit ambient isotopies is,\nin general, quite difficult. As we did in \n\nSection 5.2.1, we can simplify the concept of equality\nby moving ambient isotopy to an equivalence of knot diagrams. Taking the orthogonal projection model\nfor knot diagrams given in \n\nSection 5.2.1, ambient isotopy can be modeled as three Reidemeister\nmoves on diagrams \n\nReidemeister, 1927. Meaning, two knots are\nambient isotopic if and only if their diagrams are equal under a chain of Reidemeister moves\n\n\nReidemeister, 1927 and isotopies.\n\nThe first Reidemeister move we will define is the Type I move\n\n\nReidemeister, 1927. To carry out the Type I move\n(\n\nFigure 4), start by taking a portion of a diagram with no crossings, then add a half twist.\nWhen adding the twist, we have two choices; twist into (left handed) or out of (right handed) the\nplane the diagram lies in. In either, we can freely remove the new crossing by twisting in the\nopposite direction.\n\n\n\nFigure 4:Executing the\ntwo flavors of type I move on a knot diagram. On the left, we have\na twist into the plane, also called a positive or left-handed\ntwist. On the right,\nwe have a twist into the plane, also called a negative or right-handed twist.\n\nThe next Reidemeister move is the Type II move\n\nReidemeister, 1927,\nseen in \n\nFigure 5. When we carry out the type II move, we need two strands, each with no\ncrossings. We then pull one strand on top of the other, inducing two new crossings in our diagram.\nSimilarly to the type I move, the type II move can be freely undone by pulling the strands apart.\n\n\n\nFigure 5:Executing the two type II moves with a pair of strands. In the top image, the\nbottom strand is pulled over the upper. In the bottom image, the bottom strand\nis pulled under the top strand.\n\nThe final Reidemeister move is the Type III\nmove\n\nReidemeister, 1927. In the type III move, we take three\nstrands, two that form a crossing and a third that lies in one of three possible positions:\n\nabove the over strand\n\nbetween the over and under strands\n\nbelow the under strand\n\nWe now execute the type III by taking the third strand (not part of the center crossing) and passing\nit across the center crossing. As with type I and type II, we’re free to reverse the type III move.\n\n\n\nFigure 6:Executing the three type III moves with a set of three strands. Top\nto bottom, the third strand is:\n\non top of the crossing strands\n\nbetween the crossing strands\n\nunder the crossing strands.\n\nWe should note here that with a concept of equivalence comes equivalence classes of knot diagrams.\nHistorically, of particular interest in the tabulation of knots are the knot diagrams that have\nminimal crossing number; we call these minimal diagrams.\n\n prettier-ignore-start ","type":"content","url":"/background#subsec-knot-equivalence","position":15},{"hierarchy":{"lvl1":"Preliminaries","lvl3":"Prime Knots","lvl2":"Foundations of Knots"},"type":"lvl3","url":"/background#subsec-prime-knot","position":16},{"hierarchy":{"lvl1":"Preliminaries","lvl3":"Prime Knots","lvl2":"Foundations of Knots"},"content":" prettier-ignore-end \n\nWith the goal of enumerating objects, we should be clear on what types of objects should be\nenumerated and which should be left uncounted. We now describe the class of knot that tabulators are\ninterested in, the prime knots. The first step is to define an operation on knots called the\nconnect sum.\n\nFor knots J and K, the connect sum J\\#K is produced by:\n\nExcising an arc from both J and K\n\nGluing endpoints of J to endpoints of K\n\n\n\nFigure 7:An example of the connect sum of two trefoil knots.\n\nWith the connect sum operation defined, we are now prepared to give the definitions for prime and\ncomposite knots.\n\nA knot is called prime if, in every decomposition into a connected sum, one\nof the factors is unknotted. Otherwise, the knot is called composite.\n\n prettier-ignore-start ","type":"content","url":"/background#subsec-prime-knot","position":17},{"hierarchy":{"lvl1":"Preliminaries","lvl3":"Knot Invariants","lvl2":"Foundations of Knots"},"type":"lvl3","url":"/background#subsec-invariant","position":18},{"hierarchy":{"lvl1":"Preliminaries","lvl3":"Knot Invariants","lvl2":"Foundations of Knots"},"content":" prettier-ignore-end \n\nOur next topic of interest is that of a knot invariant. In general, an invariant for an object is a\ndatum that is computed deterministically for the object and remains unchanged within an equivalence\nclass. In the knot case, we will take the concept of equality to be that given in\n\n\nSection 5.2.2. As discussed in \n\nSection 5.1, invariants play an important\nrole in computer tabulation. We will now describe a simple invariant we first introduced in\n\n\nSection 5.2.2.","type":"content","url":"/background#subsec-invariant","position":19},{"hierarchy":{"lvl1":"Preliminaries","lvl4":"Minimal Crossing Number","lvl3":"Knot Invariants","lvl2":"Foundations of Knots"},"type":"lvl4","url":"/background#minimal-crossing-number","position":20},{"hierarchy":{"lvl1":"Preliminaries","lvl4":"Minimal Crossing Number","lvl3":"Knot Invariants","lvl2":"Foundations of Knots"},"content":"We saw at the end of \n\nSection 5.2.2 the definition of the minimal crossing number for a\nknot. That being the minimal number of crossings needed to represent the knot as a diagram. Somewhat\nintuitively, this number is an invariant for a knot. If a knot has minimal crossing number 4, we\nwill never be able to represent it with three crossings, so it has to be different from the trefoil\nknot (a knot with three crossings). However, we can see from the table of the first seven knots\n(seen in \n\nFigure 1) that having equivalent crossing number does not give us equivalent knots.\n\n","type":"content","url":"/background#minimal-crossing-number","position":21},{"hierarchy":{"lvl1":"Preliminaries","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"type":"lvl3","url":"/background#knot-notations","position":22},{"hierarchy":{"lvl1":"Preliminaries","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"content":"The final topic to cover in our treatment of foundations for knot theory is notational strategies\nfor knots. In \n\nSection 5.2.1, we came across our first notational strategy for knots, the knot\ndiagrams. While diagrams are a great human-readable way to note a knot, when the tasks of\nenumeration and computation (by hand) are considered, knot diagrams quickly show deficiencies. These\ndeficiencies become intractable when a computer is brought into the picture. As a remedy for this\nissue, knot theorists have invented several combinatorial notations for knots. Perhaps the most\nhistorically important knot notation for use in tabulation by computer is the Dowker-Thistlethwaite\n(DT) notation developed by its namesakes specifically for use in computational tabulation. Each\nnotational strategy used in knot theory has strengths and weaknesses. For example, using DT notation\nfor computation of the Jones polynomial may be more cumbersome than using the Planar Diagram (PD)\nnotation for the same task, as PD directly encodes crossings while DT encodes a walk on a strand.\nThe remainder of this section will be the development of the Conway notation, which lays the\nfoundation for the work in this thesis.\n\n prettier-ignore-start ","type":"content","url":"/background#knot-notations","position":23},{"hierarchy":{"lvl1":"Preliminaries","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"type":"lvl4","url":"/background#sec-conway","position":24},{"hierarchy":{"lvl1":"Preliminaries","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"content":" prettier-ignore-end \n\nIn \n\nSection 5.1, we saw that Conway claimed to have enumerated knots up to 11\ncrossings in “a few hours”. Conway accomplished this by breaking knots into building blocks he\ncalled tangles. This section gives an outline of the tools he developed and used to achieve those\n“few hours” of amazing efficiency. prettier-ignore-start ","type":"content","url":"/background#sec-conway","position":25},{"hierarchy":{"lvl1":"Preliminaries","lvl5":"Definition of a Tangle","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"type":"lvl5","url":"/background#subsubsec-deftangles","position":26},{"hierarchy":{"lvl1":"Preliminaries","lvl5":"Definition of a Tangle","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"content":" prettier-ignore-end \n\nOur first step in unlocking Conway’s tabulation secrets is the definition of a tangle. We will give\nConway’s original definition followed by a description of what this looks like for a three\ndimensional embedding for a knot.\n\nConway, Page 330 \n\nConway, 1970\n\nWe define a tangle as a portion of a knot diagram from which there emerge just 4\narcs pointing in the compass directions NW, \\ NE, \\ SW, \\ \\text{and }SE.\n\nThese boundaries that split knots at four points are called Conway circles, and we call the\npoints NW,\\ NE,\\ SW,\\ \\text{and }SE boundary points. Formally, we can consider a Conway circle\nto be a Jordan curve  meeting the knot diagram in exactly four points\n\n\nBonahon & Siebenmann, 2016. In general, we prefer our Conway circles to actually be\ncircles in the colloquial sense. Luckily, the circle and Jordan curve constructions are equivalent.\nThis can be seen by a straightforward isotopy of one into the other, \n\nFigure 8.\n\n\n\nFigure 8:An isotopy turning Jordan curves into circles.\n\nWe move our attention to the three dimensional analog for a Conway circle, the Conway sphere. A\nConway sphere, similar to the Conway circle, is an S^2 that encapsulates a portion of a knot so\nthat the knot intersects the sphere in exactly four points. Here we see the first example of our\npreference for ambient space to be S^3 as opposed to \\R^3. When a knot in S^3 is split by a\nConway sphere, the ambient S^3 is decomposed into two B^3, each with a portion of the knot.\nMeaning, a single Conway sphere splits a knot into a pair of tangles. prettier-ignore-start ","type":"content","url":"/background#subsubsec-deftangles","position":27},{"hierarchy":{"lvl1":"Preliminaries","lvl5":"Basic Tangles","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"type":"lvl5","url":"/background#subsubsec-basic-tangles","position":28},{"hierarchy":{"lvl1":"Preliminaries","lvl5":"Basic Tangles","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"content":" prettier-ignore-end \n\nOften, when thinking about a new construction, we focus on the simplest object that can be created\nwith the construction. In the case of drawing Conway circles to build tangles, the simplest tangles\nare a tangle with no crossings (the 0 tangle \n\nFigure 9a) and a tangle with a single\ncrossing (the +1 tangle \n\nFigure 9b).\n\n\n\n(a)A tangle with no crossings, called the 0 tangle.\n\n\n\n(b)A tangle with a single crossing, called the 1 tangle.\n\nFigure 9:Two basic tangles. prettier-ignore-start ","type":"content","url":"/background#subsubsec-basic-tangles","position":29},{"hierarchy":{"lvl1":"Preliminaries","lvl5":"Rotation and Mirroring of Tangles","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"type":"lvl5","url":"/background#subsubsec-tangle-flips","position":30},{"hierarchy":{"lvl1":"Preliminaries","lvl5":"Rotation and Mirroring of Tangles","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"content":" prettier-ignore-end \n\nConsider a generic tangle, as seen in \n\nFigure 10, where orientation (the position of\nthe NW point) of data in the interior of the Conway circle is indicated by a broken T.\n\n\n\nFigure 10:A generic tangle with a broken T.\n\nWe can manipulate this tangle by the set of rotations, clockwise or anti-clockwise. Each rotation in\nturn gives a new arrangement of the interior data. We can also manipulate the tangle by the set of\nflips, one around the core x-axis and one around the y-axis. Each flip gives an arrangement of the\ninterior data. Pairing flips with rotations gives the table seen in \n\nFigure 11.\n\n\n\nFigure 11:A table with all unique rotations and flips for a generic tangle.\nFrom top to bottom in the first column:\\ \\bullet No Flip\\ \\bullet\nFlip around the north south axis.\nFrom left to right in each row:\\ \\bullet No rotation\\ \\bullet\nrotation quarter turn clockwise\\ \\bullet rotation half turn clockwise\n\\ \\bullet rotation three quarter turn clockwise\\ \\bullet rotation\nquarter turn clockwise\n\nWhen we apply this set of flips and rotations to the basic tangles seen in \n\nBasic Tangles,\nwe obtain the two additional basic tangles seen in \n\nFigure 12.\n\n\n\n(a)A tangle with no crossings, called the \\infty tangle.\n\n\n\n(b)A tangle with a single crossing, called the  \\m 1 tangle.\n\nFigure 12:Two additional basic tangles. prettier-ignore-start ","type":"content","url":"/background#subsubsec-tangle-flips","position":31},{"hierarchy":{"lvl1":"Preliminaries","lvl5":"Operations on Tangles","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"type":"lvl5","url":"/background#subsubsec-conway-calc","position":32},{"hierarchy":{"lvl1":"Preliminaries","lvl5":"Operations on Tangles","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"content":" prettier-ignore-end \n\nIn addition to the rotations and flips, Conway introduced a calculus on tangles\n\n\nConway, 1970. This calculus allowed Conway to build the simple basic tangles\ninto iteratively more complex tangles. prettier-ignore-start ","type":"content","url":"/background#subsubsec-conway-calc","position":33},{"hierarchy":{"lvl1":"Preliminaries","lvl5":"Minus Tangle","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"type":"lvl5","url":"/background#subsubsec-conway-minus","position":34},{"hierarchy":{"lvl1":"Preliminaries","lvl5":"Minus Tangle","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"content":" prettier-ignore-end \n\nFor a generic tangle T, we call the tangle generated from a clockwise rotation and flip around the\ny-axis the negative of T, notated -T. Equivalently, this can be thought of as rotating the\ntangle around the NW and SE axis (\n\nFigure 13).\n\n\n\nFigure 13:Rotating a tangle around the NW SE diagonal, yielding the negative of the\ntangle.\n\nNote\n\nObserve that the minus of the +1 tangle (\n\nFigure 9b) is the  \\m 1\ntangle (\n\nFigure 12b). prettier-ignore-start ","type":"content","url":"/background#subsubsec-conway-minus","position":35},{"hierarchy":{"lvl1":"Preliminaries","lvl5":"Tangle Addition","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"type":"lvl5","url":"/background#subsubsec-opo-plus","position":36},{"hierarchy":{"lvl1":"Preliminaries","lvl5":"Tangle Addition","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"content":" prettier-ignore-end \n\nFor a pair of generic tangles, A and B, we construct their sum A+B by first aligning A and\nB horizontally. We then connect the NE and SE of A to the NW and SW of B, as seen in\n\n\nFigure 14.\n\n\n\nFigure 14:The sum of two generic tangles.\n\nThe class of tangles built by successive addition of the \\pm 1 basic tangles are called the\nintegral tangles.","type":"content","url":"/background#subsubsec-opo-plus","position":37},{"hierarchy":{"lvl1":"Preliminaries","lvl5":"Tangle Multiplication","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"type":"lvl5","url":"/background#tangle-multiplication","position":38},{"hierarchy":{"lvl1":"Preliminaries","lvl5":"Tangle Multiplication","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"content":"For a pair of generic tangles, A and B, we construct their product, A*B (or A\\ B) by first\naligning A and B horizontally. We then take -A and sum the two resulting tangles, equivalent\nto -A+B, as seen in \n\nFigure 15.\n\n\n\nFigure 15:The product of two generic tangles\n\nNote\n\nNotice thatA*0=-A+0=-A","type":"content","url":"/background#tangle-multiplication","position":39},{"hierarchy":{"lvl1":"Preliminaries","lvl5":"Tangle Ramification","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"type":"lvl5","url":"/background#tangle-ramification","position":40},{"hierarchy":{"lvl1":"Preliminaries","lvl5":"Tangle Ramification","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"content":"For a pair of generic tangles, A and B, we construct their ramification A,B by first aligning\nA and B horizontally. We then take -A and -B and sum the resulting tangles. This makes\nramification equivalent to -A-B or A0+B0, as seen in \n\nFigure 16.\n\n\n\nFigure 16:The ramification of two generic tangles. prettier-ignore-start ","type":"content","url":"/background#tangle-ramification","position":41},{"hierarchy":{"lvl1":"Preliminaries","lvl5":"Indicating Precedence","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"type":"lvl5","url":"/background#subsubsec-opo-precedence","position":42},{"hierarchy":{"lvl1":"Preliminaries","lvl5":"Indicating Precedence","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"content":" prettier-ignore-end \n\nWith a set of operations comes the desire to chain multiple operations together. The precedence for\noperations on tangles is indicated by parentheses in the obvious way (\n\nFigure 17).\n\n\n\nFigure 17:Multiple operations chained together with precedence indicated by parentheses. prettier-ignore-start ","type":"content","url":"/background#subsubsec-opo-precedence","position":43},{"hierarchy":{"lvl1":"Preliminaries","lvl5":"The Flype","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"type":"lvl5","url":"/background#subsubsec-opo-flype","position":44},{"hierarchy":{"lvl1":"Preliminaries","lvl5":"The Flype","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"content":" prettier-ignore-end \n\nWhen working in this calculus of tangles, a common situation you find yourself in is one where the\n1 (or \\m 1) tangle is added to a tangle. In this situation, we can move the 1 crossing from\none side of T to the other by a flype. To complete a flype, we grab the top (north) and bottom\n(south) of the tangle and rotate (opposite the handedness of the crossing) as in \n\nFigure 18.\n\n\n\nFigure 18:A (+)-flype on the top and a (-)-flype on the bottom. Note that the generic\ntangle is flipped around the x-axis during the flype.","type":"content","url":"/background#subsubsec-opo-flype","position":45},{"hierarchy":{"lvl1":"Preliminaries","lvl5":"Closures","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"type":"lvl5","url":"/background#closures","position":46},{"hierarchy":{"lvl1":"Preliminaries","lvl5":"Closures","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"content":"Since Conway’s interest was in knots, he naturally needed ways to close up a tangle to form a knot.\nIn this section, we will introduce two ways that this can be accomplished. The first closure method\nis the simple tangle closure, where points on a tangle are connected. The second closure method is\nthe insertion of multiple tangles into a graph.","type":"content","url":"/background#closures","position":47},{"hierarchy":{"lvl1":"Preliminaries","lvl6":"Simple Tangle Closures","lvl5":"Closures","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"type":"lvl6","url":"/background#simple-tangle-closures","position":48},{"hierarchy":{"lvl1":"Preliminaries","lvl6":"Simple Tangle Closures","lvl5":"Closures","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"content":"The first closure method is the simple tangle closure. For a generic tangle T, we have two options\nfor how to simply close up the tangle. One option is to connect a strand from NW to NE and a\nstrand from SW to SE (\n\nFigure 19a), called the numerator closure. The alternative is the\ndenominator closure, formed by connecting a strand from NW to SW and a strand from NE to SE\n(\n\nFigure 19b). In both cases, we introduce no additional crossings.\n\n\n\n(a)The numerator closure of a tangle.\n\n\n\n(b)The denominator closure of a tangle.\n\nFigure 19:The two simple closures of a tangle. prettier-ignore-start ","type":"content","url":"/background#simple-tangle-closures","position":49},{"hierarchy":{"lvl1":"Preliminaries","lvl6":"Tangle insertions","lvl5":"Closures","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"type":"lvl6","url":"/background#subsubsec-opo-insert","position":50},{"hierarchy":{"lvl1":"Preliminaries","lvl6":"Tangle insertions","lvl5":"Closures","lvl4":"Conway Notation","lvl3":"Knot Notations","lvl2":"Foundations of Knots"},"content":" prettier-ignore-end \n\nWith the calculus of tangles and simple closures, Conway was able to enumerate a substantial number\nof knots, but not all. We should notice a common theme with the calculus, when starting with basic\ntangles every operation forms a bigon. We can collapse bigons in the knot shadow by deleting\nedges and merging the two vertices of a bigon. For a knot formed by only the operations and simple\nclosures, if we iteratively collapse all bigons we obtain a four-valent planar graph  with\none vertex, per \n\nFigure 20. The class of knots who have a presentation where bigons can be\ncollapsed to a single vertex with two self edges are called the algebraic knots.\n\n\n\nFigure 20:The collapsing of the bigons in a knot\nshadow from left to right: \\ \\bullet A trefoil knot. \\ \\bullet A\nknot shadow for a trefoil knot with a\nbigon highlighted. \\ \\bullet The previously highlighted bigon\ncollapsed, and a new\nbigon highlighted. \\ \\bullet A graph with no bigons.\n\nTo obtain a knot that has non-bigon connections between inputs, we will first identify a four-valent\nplanar graph that has non-bigon connections between vertices. The class of graph that is most useful\nhere are the polygon graphs. For example, the 6^{**} graph (or octahedron) can be seen in\n\n\nFigure 21. Within the 6^{**} graph, we notice triangular regions between vertices.\n\n\n\nFigure 21:A four valent planar graph with six vertices and triangular regions between\nvertices. When the graph is placed on the surface of an S^2 we get the\noctahedron.\n\nThe simplest thing we can do from here is consider the graph as a knot shadow, and for each vertex,\nchoose an over and under strand. While that method would give us a knot, it is limiting. Less\nlimiting is a process of tangle insertion. In this process we consider each vertex a boundary of a\nConway circle in which we can place a tangle generated with the Conway calculus. When we insert the\ntangle into the Conway circle (vertex in the graph), the NW,\\,NE,\\,SW,\\,\\text{and }SE points of\nthe tangle are connected to marked points of the Conway circle (the four edges of the vertex). An\nexample of a tangle insertion into 6^{**} can be seen in \n\nFigure 22.\n\n\n\nFigure 22:Tangles inserted into the 6^{**}\ntangle, with Conway notation \n\n6^{**}\\ast.1\\ 2\\ 2\\ 3\\ 1.1\\ 2\\ 2\\ 3\\ 1.1\\ 2\\ 2\\ 3\\ 1.1\\ 2\\ 2\\ 3\\ 1.1\\ 2\\ 2\\ 3\\ 1\n\nThe \\ast labeled vertex defines the four boundary points of the\nresulting tangle.\n\nWhen each vertex has a tangle inserted, the result is a knot. When n vertices are left empty, the\nresult is a tangle with n boundary Conway circles. If n is 1, we have a tangle in the sense\nwe’ve been discussing. To reduce ambiguity, we mark in the graph with a \\ast in that empty vertex.\nOn each polygon graph, we select a canonical ordering of the vertices, per \n\nFigure 23.\nWhen notating the tangle insertions, we list the subtangles we wish to insert in graph canonical\norder, each separated by a period and an empty vertex indicated with \\ast. Following the\nterminology outlined by Conolly \n\nConnolly, 2021, we call these\nsingularly marked polygonal graphs constellations. We call the tangle diagrams generated by this\napproach the polygonal diagrams. If a tangle has no algebraic representative we call it a\npolygonal tangle.\n\n\n\nFigure 23:The 6^{\\ast\\ast} graph with an order applied.\n\nNote\n\nObserve that insertion into the one vertex graph is equivalent to the simple\ntangle closures.\n\nA Jordan curve is a simple closed curve. This can be thought of as a curve drawn on a piece of\npaper that has: 1) No end points. 2) No self intersections.\n\nA bigon is a polygon with two sides. In the same way that an octagon has eight sides or a trigon\n(triangle) has three.\n\nA graph is said to be four valent if each vertex has four edge ends connected to it. In\n\n\nFigure 20, the result is four valent.\n\n","type":"content","url":"/background#subsubsec-opo-insert","position":51},{"hierarchy":{"lvl1":"Preliminaries","lvl2":"Foundations of Tangles"},"type":"lvl2","url":"/background#foundations-of-tangles","position":52},{"hierarchy":{"lvl1":"Preliminaries","lvl2":"Foundations of Tangles"},"content":"So far we have used tangles as a building block for knots, we will switch gears slightly to consider\na tangle as our main object of interest. This section will give the foundations of the theory of\ntangles needed for the remainder of this thesis.","type":"content","url":"/background#foundations-of-tangles","position":53},{"hierarchy":{"lvl1":"Preliminaries","lvl3":"Tangle Equivalence","lvl2":"Foundations of Tangles"},"type":"lvl3","url":"/background#tangle-equivalence","position":54},{"hierarchy":{"lvl1":"Preliminaries","lvl3":"Tangle Equivalence","lvl2":"Foundations of Tangles"},"content":"As we saw for knots in \n\nSection 5.2.2, if we want to tell two tangles apart, we first need\nto be able to identify when tangles are the same. Our development of the concept of equality of\ntangles follows closely that of knots. From \n\nDefinition of a Tangle, we have definitions for tangles\nin the context of knot diagrams and three-dimensional embeddings of knots. This tells us that the\nconcepts of equality developed in \n\nSection 5.2.2, namely ambient isotopy and Reidemeister\nmoves, will apply in the tangle case with two key differences.\n\nThe first difference with tangles when compared to knots is that we restrict ambient isotopy and\nReidemeister moves from pushing a strand through the Conway sphere (Conway circle). The second\ndifference is the handling of the boundary points. There are two conventions for how to handle\nequality with the boundary points; first allowing the boundary points to move on the Conway sphere,\nand second fixing the boundary points on the Conway sphere.","type":"content","url":"/background#tangle-equivalence","position":55},{"hierarchy":{"lvl1":"Preliminaries","lvl4":"Moveable Boundary Points","lvl3":"Tangle Equivalence","lvl2":"Foundations of Tangles"},"type":"lvl4","url":"/background#moveable-boundary-points","position":56},{"hierarchy":{"lvl1":"Preliminaries","lvl4":"Moveable Boundary Points","lvl3":"Tangle Equivalence","lvl2":"Foundations of Tangles"},"content":"Our first case for handling the boundary of a tangle is allowing the boundary points to move freely\non the Conway sphere. In this case, a generic tangle is equivalent to each of its rotations and\nflips (\n\nRotation and Mirroring of Tangles). In addition to the rotation and flip equivalence, a moveable\nboundary allows us to unwind the outermost integral components of a tangle\n(\n\nFigure 24).\n\n\n\nFigure 24:The progressive unwinding of integral tangles, leaving a basic 0 tangle.\n\nNote\n\nIn the moveable boundary case, there is only one basic tangle, the 0 tangle.\n\nFor this thesis, we will assume tangles have a fixed boundary unless explicitly mentioned.","type":"content","url":"/background#moveable-boundary-points","position":57},{"hierarchy":{"lvl1":"Preliminaries","lvl4":"Non-moveable Boundary Points","lvl3":"Tangle Equivalence","lvl2":"Foundations of Tangles"},"type":"lvl4","url":"/background#non-moveable-boundary-points","position":58},{"hierarchy":{"lvl1":"Preliminaries","lvl4":"Non-moveable Boundary Points","lvl3":"Tangle Equivalence","lvl2":"Foundations of Tangles"},"content":"The non-moveable case is the more straightforward of the two boundary concepts of equality for\ntangles. In the fixed boundary world, we have four distinct basic tangles\n1,\\ \\ \\m 1,\\ 0,\\ \\text{and } \\infty seen in \n\nFigure 9 and \n\nFigure 12. These\nare all distinct when the boundary is fixed. In \n\nFigure 25 we find two tangles, each with\ntwo crossings but not equivalent by Reidemeister moves.\n\n\n\n(a)A horizontal integral tangle with two crossings.\n\n\n\n(b)A vertical integral tangle with two crossings.\n\nFigure 25:Two nonequivalent tangles with two crossings. prettier-ignore-start ","type":"content","url":"/background#non-moveable-boundary-points","position":59},{"hierarchy":{"lvl1":"Preliminaries","lvl3":"Modified Tangle Operations","lvl2":"Foundations of Tangles"},"type":"lvl3","url":"/background#subsec-tangle-operations","position":60},{"hierarchy":{"lvl1":"Preliminaries","lvl3":"Modified Tangle Operations","lvl2":"Foundations of Tangles"},"content":" prettier-ignore-end \n\nIn \n\nOperations on Tangles we saw Conway’s calculus of tangles. While this construction is powerful\nand flexible, it’s rather unintuitive and cumbersome when combined with computer methods. In this\nsection, we will describe a slightly modified, but equivalent, version of the calculus. This version\nof tangle arithmetic is due to Kauffman and Goldman \n\nGoldman & Kauffman, 1997.\n\nInstead of Conway’s three operations on the two basic tangles 1 and 0, this arithmetic needs the\ntwo basic operations and all four basic tangles (\n\nFigure 9 and \n\nFigure 12).\nThe first operation in this arithmetic is exactly Conway’s horizontal sum, + (\n\nFigure 14). The\nsecond operation is the vertical sum, \\vee, sometimes written *\n\nGoldman & Kauffman, 1997 or\n+^\\prime\n\nKauffman & Lambropoulou, 2002. For generic tangle A and B, A\\vee B is\nbuilt analogously to the + but stacking A vertically on top of B instead of horizontally\n(\n\nFigure 26).\n\n\n\nFigure 26:The vertical sum of two generic tangles.\n\nThese two operations combined with parentheses as in \n\nIndicating Precedence give a natural\narithmetic structure to the combinations of tangles. We’ll see in later sections how this structure\nis easily encoded on a computer as a data structure. We conclude the section by redefining the\nalgebraic tangles.\n\nConway, Page 331 \n\nConway, 1970\n\nAny tangle that can be produced by the two binary operations + and \\vee on\nthe four basic tangles is called an algebraic tangle. prettier-ignore-start ","type":"content","url":"/background#subsec-tangle-operations","position":61},{"hierarchy":{"lvl1":"Preliminaries","lvl3":"Integral Tangles","lvl2":"Foundations of Tangles"},"type":"lvl3","url":"/background#subsec-integral-tangle","position":62},{"hierarchy":{"lvl1":"Preliminaries","lvl3":"Integral Tangles","lvl2":"Foundations of Tangles"},"content":" prettier-ignore-end \n\nWe finish the chapter with a description of a class of tangles we first encountered in\n\n\nTangle Addition. The integral tangles are the simplest class of tangle that are built from the\nbasic operations on basic tangles. We start by defining the  \\pm horizontal integral tangles.\n\nA tangle built from the successive sum of n +1 tangles is called a\nhorizontal integral (or simply integral) n tangle. Similarly, a sum of \\ \\m 1 tangles is a\nhorizontal integral  -n tangle.\n\nIt is convenient to notate the horizontal integral tangles simply by their corresponding integer,\n\\pm n. A similar construction can be defined for the \\vee operation, yielding the  \\pm\nvertical integral tangles.\n\nA tangle built from the successive vertical sum of n +1 tangles is called a\nvertical integral n tangle. Similarly, a vertical sum of \\m 1 tangles is a\nvertical integral \\m n tangle.\n\nWe will notate the vertical tangles by \\pm\\frac{1}{n}.","type":"content","url":"/background#subsec-integral-tangle","position":63},{"hierarchy":{"lvl1":"Software and its Engineering"},"type":"lvl1","url":"/software","position":0},{"hierarchy":{"lvl1":"Software and its Engineering"},"content":"We now shift from the mathematical world to the world of computers and software. We start with a\nbrief overview of the goals of product management and software engineering\n(\n\nSection 7.1.1). This includes the development of model software engineering processes\ntailored for use in professional and undergraduate mathematics research. Next, we use the\nengineering concepts of \n\nSection 7.1.1 to compare and contrast a collection of tools\ncurrently available for use in knot theory research (\n\nSection 7.2). Using the analysis of\ncurrent tools, and our software process we define a set of requirements and a system design for a\nnew general purpose knot theory software toolbox (\n\nSection 7.3). Finally, using this system\ndesign, and following our process, we present documentation for the software units that satisfy the\ntabulation theory of \n\nChapter 6 Tabulation.","type":"content","url":"/software","position":1},{"hierarchy":{"lvl1":"Software and its Engineering","lvl2":"Basics of Product Management and Software Engineering"},"type":"lvl2","url":"/software#basics-of-product-management-and-software-engineering","position":2},{"hierarchy":{"lvl1":"Software and its Engineering","lvl2":"Basics of Product Management and Software Engineering"},"content":" prettier-ignore-start ","type":"content","url":"/software#basics-of-product-management-and-software-engineering","position":3},{"hierarchy":{"lvl1":"Software and its Engineering","lvl3":"Project vs. Product","lvl2":"Basics of Product Management and Software Engineering"},"type":"lvl3","url":"/software#sec-product-vs-project","position":4},{"hierarchy":{"lvl1":"Software and its Engineering","lvl3":"Project vs. Product","lvl2":"Basics of Product Management and Software Engineering"},"content":" prettier-ignore-end \n\nOne of the most pervasive ideas held by amateur software developers is that documentation means\nsimply commenting your code. This idea and its consequences are one of the fundamental\ndifferentiators between a piece of software being a project or becoming a product. A project is\nshort-lived with no consideration of long-term reuse or usage by a community. Much preferred is the\ncreation of products that are long-term, reusable, extensible, and portable investments of time and\nenergy (effort).\n\nThe creation of a product requires planning and documentation of a system far beyond simple code\ncomments. When developing a product, we must include thoughtful and deliberate consideration of the\ngoals and how we will achieve them. For example, identifying where effort invested now to create a\nrobust system can save effort later, and enumerating and analyzing risk to the product can reduce\nthe chance of total product failure.\n\nThe creation of a software product has two phases, a generic (not software specific) high-level\nproduct management/development phase followed by a detailed software engineering phase. Having this\ntwo-pass approach allows for the product to be well and thoroughly defined and assessed before any\ntechnical engineering work is started, reducing the risk of a product being intractable based on the\nproduct constraints. The remainder of this chapter will give context to product management and\nsoftware engineering practices, with preparing undergraduates for research as the goal. We will\nstart with a design for a course on teaching project management to undergraduate researchers. We\nthen develop a software engineering process for use in mathematics research.\n\n prettier-ignore-start ","type":"content","url":"/software#sec-product-vs-project","position":5},{"hierarchy":{"lvl1":"Software and its Engineering","lvl3":"Instruction of Product Management","lvl2":"Basics of Product Management and Software Engineering"},"type":"lvl3","url":"/software#sec-product-management","position":6},{"hierarchy":{"lvl1":"Software and its Engineering","lvl3":"Instruction of Product Management","lvl2":"Basics of Product Management and Software Engineering"},"content":" prettier-ignore-end \n\nUndergraduate researchers, in most academic disciplines, have little exposure to systematic product\nmanagement. Outside a structured classroom setting, an undergraduate researcher may have never\ncompleted a project, let alone worked on a product. Giving undergraduate researchers a minimal set\nof product management tools increases their ability to estimate and bring together successful\nproducts.\n\nIn this section we describe a course design for a basic undergraduate course in product management.\nThe perspective of the course design is not software focused but is intended for general use across\ndisciplines. In six weeks of instruction, this course introduces students to the key concepts in\nproduct management needed to ideate and systematically complete complex products. The design\nutilizes the “Backward Design” of Wiggins and McTighe \n\nWiggins & McTighe, 2008. Many of the\nideas come from Pressman and Maxim \n\nPressman & Maxim, 2015 but have been\nmassaged to be less software focused. Full course design and template documents are found published\non GitHub \n\nStarr, 2025.\n\n prettier-ignore-start ","type":"content","url":"/software#sec-product-management","position":7},{"hierarchy":{"lvl1":"Software and its Engineering","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"type":"lvl3","url":"/software#sec-life-cycle","position":8},{"hierarchy":{"lvl1":"Software and its Engineering","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"content":" prettier-ignore-end \n\nThe second stage of software product development is the software engineering process. Just as in the\nproduct management section (\n\nSection 7.1.2), we are approaching the software engineering\nprocess from an undergraduate training perspective. However, unlike our discussion of general\nproduct management, we assume some prior knowledge of software practices. We assume familiarity with\nprogramming, types of programming languages, and the basic structure of a program. If the reader\nfeels unprepared, they may find it useful to complete one of the many free asynchronous online\ncourses offered by major universities and browse a standard introduction to computation\ntext such as “Introduction to the Theory of Computation” by Sipser\n\n\nSipser, 2013. With this in mind, we will focus on engineering\nprocesses needed for our tangle tabulation use case, omitting discussion of the practice of\nprogramming itself.\n\nWe will first define what steps we will take as part of our model process and any quality\ngates to be satisfied before moving between those steps. We call this collection of steps and\ntransitions a software life cycle. Rather than reinventing the wheel, we will build on top of an\nexisting life cycle model. There are several existing models available to us, the most common\nprocesses used in industry are agile models such as extreme programming\n\n\nBeck & Andres, 2012 (\n\nFigure 1a) and scrum \n\nNonaka & Takeuchi, 1986\n(\n\nFigure 1b). Less common in industry but historically relevant are linear models such as the\nwaterfall\n\nBenington, 1983 (\n\nFigure 1c) or the V\nmodel\n\nForsberg & Mooz, 1991 (\n\nFigure 1d).\n\n\n\n(a)The extreme programing agile life cycle\n\nDonWells, 2010.\n\n\n\n(b)The scrum agile life cycle \n\nLakeworks, 2008.\n\n\n\n(c)The waterfall process model. Note that the model allows no back tracking.\n\n\n\n(d)The V process model.\n\nLife cycle diagrams of two agile and two linear process models.\n\nAgile processes have become ubiquitous in industry as they allow for tight feedback loops which\nensures the product meets the needs of stakeholders, reducing the risk of misunderstandings. In a\nresearch context, by the time product software is being written, requirements and expectations for\nthe software are necessarily fully understood and well-defined. Consequently, and contrary to\nindustry trends, linear models are the most appropriate for research contexts. While researchers can\nbe expected to define well-considered requirements, as amateur software engineers, it is rare that\nthe design and programming techniques are mature enough to support the strict progression of a\nwaterfall process. As such, a V model where downstream phases feed back into previous phases is\nideal. For our model process, however, we will make a single change, disallowing feedback caused by\ndownstream phases to change requirements, as seen in \n\nFigure 2.\n\n\n\nFigure 2:The feature V process model.\n\nOften software products are developed by teams of engineers. In these team environments, it is\nimportant that the software process be easily parallelizable. Our modified V model can be\nparallelized as in \n\nFigure 3. Allowing the process to be utilized by individual\nresearchers at primarily undergraduate institutions or large REU projects.\n\n\n\nFigure 3:The feature V process model.\n\nThe remainder of this section describes each phase of our modified V model. In each subsection, we\nwill describe the activities that should be carried out during that phase, as well as an overview of\nwhat, if any, diagrams we should expect to be created. The diagrams we will discuss for each phase\nare simplifications of standard UML \n\nUnified Modeling Language, v2.5.1, 2017 diagrams. Throughout the phases,\nwe will use an implementation of the game of “Go Fish” as an example software product.\n\nNote\n\nSince the rules of “Go Fish” are highly non-standard, we will use the\nrules defined by Parlett \n\nParlett, 2009, page 397 as a common base.\n\n prettier-ignore-start ","type":"content","url":"/software#sec-life-cycle","position":9},{"hierarchy":{"lvl1":"Software and its Engineering","lvl4":"Requirements","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"type":"lvl4","url":"/software#subsec-requirements","position":10},{"hierarchy":{"lvl1":"Software and its Engineering","lvl4":"Requirements","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"content":" prettier-ignore-end \n\nRequirements define the conditions and behaviors that are expected out of a system. Writing specific\nand non-ambiguous requirements is a surprisingly difficult task, for example, when writing a set of\nrequirements for “Go Fish” we may define a requirement such as \n\nExample 1.\n\nA requirement for a fishing action\n\nRequirement: Player Goes Fishing\n\nAt the beginning of the active player’s turn that player shall request a\ncard from any other player.\n\nNote\n\nObserve the indicative mood used in \n\nExample 1. The indicative mood, as in\nthe use of “shall,” helps the designer reduce ambiguity by sharpening precision.\n\nOn its face, \n\nExample 1 seems to be a perfectly good requirement phrasing the “fishing” phase\nof a turn. However, if you put yourself in the shoes of a person who has never played “Go Fish,” you\nmight be confused by how to ask for a card. Can the active player ask for a 10, or should they ask\nspecifically for a 10\\heartsuit? Fixing this ambiguity in \n\nExample 1 can by done by making\nthe requirement more precises \n\nExample 2.\n\nAn updated requirement for a fishing action\n\nRequirement: Player Goes Fishing\n\nAt the beginning of the active player’s turn that player shall request a\ncard, by rank and suit, from any other player.\n\nIn a research context, the phrasing of a requirement, as in \n\nExample 2 is often\nredundant. Most pieces of software in a rigorous mathematical context will have backing from\ntheorems and definitions that unambiguously define what the software should do. This means we must\nchange how we think about requirements in the research setting. Instead of requirements of the style\nof \n\nExample 2 we phrase requirements as use cases.\n\nParaphrasing Pressman and Maxim, Page 149 \n\nPressman & Maxim, 2015\n\nA use case tells a stylized story about how an end user (playing one of a number\nof possible roles) interacts with the system under a specific set of\ncircumstances. The story may be narrative text, an outline of tasks or\ninteractions, a template-based description, or a diagrammatic representation.\n\nIn this context, we may rephrase \n\nExample 2 as a use case, such as \n\nExample 3.\n\nA usecase for a fishing action\n\nUse Case: Player Goes Fishing\n\nA player asks another player for a specific card (rank and suit).","type":"content","url":"/software#subsec-requirements","position":11},{"hierarchy":{"lvl1":"Software and its Engineering","lvl5":"Use Case Diagram","lvl4":"Requirements","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"type":"lvl5","url":"/software#use-case-diagram","position":12},{"hierarchy":{"lvl1":"Software and its Engineering","lvl5":"Use Case Diagram","lvl4":"Requirements","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"content":"One popular way to phrase and visualize a collection of use cases is a use case diagram\n\n\nUnified Modeling Language, v2.5.1, 2017. A use case diagram shows the connections between actors (Player and\nDealer in \n\nExample 4) and use cases (oval cells in \n\nExample 4). When an actor is connected\nto a use case, we interpret that connection as the user being able to initiate (kicking off the\nstory the use case tells) that use case. In \n\nExample 4 we have a connection between use cases,\nthe “include” connection, this connection models a use case initiating another use case. The\n“include” relationship is useful for generalizing behavior, in \n\nExample 4 we see the matching\nuse case included in both the fishing and drawing use cases.\n\nA use case diagram for Go Fishflowchart LR\n\n    player[\"Player fa:fa-user\"]\n    dealer[\"Dealer fa:fa-user\"]\n    P1([Fishes for a card])\n    P2([Matches four cards<br> into a 'book'.])\n    P3([Draw a card from the deck])\n    D1([Shuffle the deck])\n    player --> P1\n    player --> P3\n    dealer --> D1\n    P1 -. include .-> P2\n    P3 -. include .-> P2\n\n prettier-ignore-start ","type":"content","url":"/software#use-case-diagram","position":13},{"hierarchy":{"lvl1":"Software and its Engineering","lvl4":"Software Design","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"type":"lvl4","url":"/software#subsec-softearedesign","position":14},{"hierarchy":{"lvl1":"Software and its Engineering","lvl4":"Software Design","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"content":" prettier-ignore-end \n\nAfter expectations of a system are set in the requirements phase, we can decompose the problem into\na software design. Pressman and Maxim \n\nPressman & Maxim, 2015 outline eight\nprinciples (\n\nDefinition 2) that guide this process. This problem decomposition tells us how to break\nthe software into discrete pieces of functionality called units. Depending on the team, their\nneeds, and the technologies they are using, a unit can be sized anywhere from a single function to a\ncollection of files.\n\nParaphrasing Pressman and Maxim, Section 7.2.2 \n\nPressman & Maxim, 2015\n\nDivide and conquer: You should break a hard problem into smaller solvable\nproblems where possible.\n\nUnderstand the use of abstraction: Solving your problem is good, solving a\nmore general version of your problem is better. Write software that hits the\n“sweet spot” of abstraction. Software that is not too general that it’s hard\nto use for your specifc needs, and not to specialized that you can’t use it\nagain for a similar problem.\n\nStrive for consistency: It’s easier to use/build intuition when choices are\nconsistent. When you open a textbook, why is it easy to find the index?\nBecause they are consistently in the same location.\n\nFocus on the transfer of information: Software, at its most basic, is about\nmanipulating data. Knowing where that data moves and how it’s consumed\nis key to understanding and contextualizing a problem.\n\nBuild software that exhibits effective modularity: When decomposing a problem\nas in (1), the smaller problems should have low coupling (see \n\nDefinition 3) and\nhigh cohesion (see \n\nDefinition 4).\n\nLook for patterns: Look for ways common design patterns (see \n\nDefinition 5) can\nbe used to solve the problem.\n\nWhen possible, represent the problem and its solution from a number of\ndifferent perspectives: It’s often the case that the first solution (obvious\nsolution) is not the best/ideal solution. Approaching a problem from many\nperspectives helps identify alternative solutions.\n\nRemember that someone will maintain the software: “Be kind to future you.”\nSpend an hour now to save days later.\n\nParaphrasing Pressman and Maxim, Section 14.2.4 \n\nPressman & Maxim, 2015\n\nCoupling is a qualitative measure of the degree to which units are\nconnected to one another. As units become more interdependent, coupling\nincreases.\n\nParaphrasing Pressman and Maxim, Section 14.2.3 \n\nPressman & Maxim, 2015\n\nWithin the context of unit-level design for systems, cohesion implies that a\nunit encapsulates only attributes and operations that are closely\nrelated to one another and to the unit itself.\n\nParaphrasing Pressman and Maxim, Page 349\n\nPressman & Maxim, 2015\n\nA design pattern is an abstraction that prescribes a design solution to a\nspecific, well-bounded design problem. A design pattern saves you from\n“reinventing the wheel,” or worse, inventing a “new wheel” that is slightly out\nof round, too small for its intended use, and too narrow for the ground it will\nroll over.\n\nAs an example we give a common design pattern the Iterator Pattern\n\nGamma, 1995:\n\nIntent\n\nProvide a way to access the elements of an aggregate object sequentially without\nexposing its underlying representation.\n\nMotivation\n\nAn aggregate object such as a list should give you a way to access its elements\nwithout exposing its internal structure. Moreover, you might want to traverse\nthe list in different ways, depending on what you want to accomplish. But you\nprobably don’t want to bloat the List interface with operations for different\ntraversals, even if you could anticipate the ones you will need. You might also\nneed to have more than one traversal pending on the same list.\n\nThe Iterator pattern lets you do all this. The key idea in this pattern is to\ntake the responsibility for access and traversal out of the list object and put\nit into an iterator object. The Iterator class defines an interface for\naccessing the list’s elements. An iterator object is responsible for keeping\ntrack of the current element; that is, it knows which elements have been\ntraversed already.\n\nApplicability\n\nUse the Iterator pattern:\n\nto access an aggregate object’s contents without exposing its internal\nrepresentation.\n\nto support multiple traversals of aggregate objects.\n\nto provide a uniform interface for traversing different aggregate structures\n(that is, to support polymorphic iteration).","type":"content","url":"/software#subsec-softearedesign","position":15},{"hierarchy":{"lvl1":"Software and its Engineering","lvl5":"Diagrams","lvl4":"Software Design","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"type":"lvl5","url":"/software#diagrams","position":16},{"hierarchy":{"lvl1":"Software and its Engineering","lvl5":"Diagrams","lvl4":"Software Design","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"content":"","type":"content","url":"/software#diagrams","position":17},{"hierarchy":{"lvl1":"Software and its Engineering","lvl6":"Block Diagram","lvl5":"Diagrams","lvl4":"Software Design","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"type":"lvl6","url":"/software#block-diagram","position":18},{"hierarchy":{"lvl1":"Software and its Engineering","lvl6":"Block Diagram","lvl5":"Diagrams","lvl4":"Software Design","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"content":"To diagrammatically represent a software design, we utilize a modified block diagram. A block\ndiagram gives a high-level description of the discrete units of a software design and how those\nunits relate to each other. The units are given by blocks containing a descriptive title. Units that\nsatisfy similar use cases and may be abstractable to a common design are grouped together in\ncontainer blocks (User Interface in \n\nExample 5). Connections between blocks are recorded with\ndecorated arrows, the decorations indicate the multiplicity of the relationship between components,\nsuch as 1 for a one-to-one, 1..* for a 1 to many, or *..1 for a many to 1 mapping.\n\nA block diagram for Go Fish\n\nflowchart LR\n    subgraph User Interface\n        ui-hd[\"Hand Display\"]\n        ui-dd[\"Deck Display\"]\n        ui-ps[\"Player Score\"]\n    end\n\n    subgraph Game Objects\n        go-h[\"Hand\"]\n        go-d[\"Deck\"]\n    end\n\n    gs[\"Game State\"]\n\n     go-h --->|*..1| gs\n     go-d --->|1| gs\n     gs --->|1| ui-hd\n     gs --->|1| ui-dd\n     gs --->|1..*| ui-ps","type":"content","url":"/software#block-diagram","position":19},{"hierarchy":{"lvl1":"Software and its Engineering","lvl6":"Sequence Diagram","lvl5":"Diagrams","lvl4":"Software Design","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"type":"lvl6","url":"/software#sequence-diagram","position":20},{"hierarchy":{"lvl1":"Software and its Engineering","lvl6":"Sequence Diagram","lvl5":"Diagrams","lvl4":"Software Design","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"content":"When the software design must account for communication between units, a sequence diagram may be\nused. A sequence diagram records the actions and data transfers that actors (units) take during a\nuse case. A sequence diagram encodes time on the vertical axis, with actors as vertical lanes.\nInteractions between actors over time are indicated by annotated arrows between lanes. Arrow\nannotations are a description of the interaction taking place. Conditional sequences are indicated\nby boxes delimiting the possible sequences of the interaction (is negative and is positive\nsubsequences in \n\nExample 6).\n\nA sequence diagram for Go Fish turn\n\nsequenceDiagram\n    participant o as Player 1\n    participant t as Player 2\n    participant d as Deck\n\n    o ->> t: Asks for a card\n    alt is negative\n    t ->> o: Responds in the negative\n    o ->> d: Requests a card\n    d ->> o: Distributes a card\n    else is positive\n    t ->> o: Responds in the postive\n    t ->> o: Distributes a card\n    end\n\n prettier-ignore-start ","type":"content","url":"/software#sequence-diagram","position":21},{"hierarchy":{"lvl1":"Software and its Engineering","lvl4":"Unit Design","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"type":"lvl4","url":"/software#sec-product-unit-design","position":22},{"hierarchy":{"lvl1":"Software and its Engineering","lvl4":"Unit Design","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"content":" prettier-ignore-end \n\nAs we proceed down the left side of the V model, we narrow our focus, progressively becoming less\nabstract and more concrete in our representation of our software. The software design gives us a\ndescription of what units we will need, but does not give an actionable description of those units.\nA unit description gives that actionable description, a language agnostic but directly implementable\n(programmable) description for what a unit contains and how a unit works.\n\nA description for a unit contains the data members (variables) and the functional members a unit\ncontains. Each of these items is described in two ways, first a plain English description, and\nsecond included diagrammatically in a class diagram \n\nUnified Modeling Language, v2.5.1, 2017 for the unit. The\nplain English description for each member describes what that member is intended to be or do. In the\ncase of a functional memember, along with an English description, a diagrammatic definition as a\nstate machine\n\nUnified Modeling Language, v2.5.1, 2017 should also be given.\n\nAs with the special language/mood used when designing requirements (\n\nSection 7.1.3.1),\ndocumentation at the unit level and below have a particular frugal and direct style. When this style\nis first encountered it can be jarring, and the writing appear shockingly poor. However, just as the\nuse of the indicative mood in requirements encourages precision, the style of documentation at this\nlevel serves a purpose. Documentation at this level is not intended to tell a story or describe a\nproblem, but to directly define a computational unit one layer of abstraction above code. Simple\ndirect language here encourages the clear communication of expectations and intents that translate\nto code. Complicated ideas, at this level, are easier to express (and consume) when presented\ndiagrammatically. Our English descriptions serve simply to supplement the diagrams.\n\nNote\n\nWriting long, elaborate explanations at the unit level should prompt you to\nengage in analysis of your design. The need for explanations like this\noften indicates you are missing something at the software design\nlevel, look for\nmissing abstraction or a place to divide and conquer.","type":"content","url":"/software#sec-product-unit-design","position":23},{"hierarchy":{"lvl1":"Software and its Engineering","lvl5":"Diagrams","lvl4":"Unit Design","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"type":"lvl5","url":"/software#diagrams-1","position":24},{"hierarchy":{"lvl1":"Software and its Engineering","lvl5":"Diagrams","lvl4":"Unit Design","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"content":"","type":"content","url":"/software#diagrams-1","position":25},{"hierarchy":{"lvl1":"Software and its Engineering","lvl6":"Class Diagram","lvl5":"Diagrams","lvl4":"Unit Design","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"type":"lvl6","url":"/software#class-diagram","position":26},{"hierarchy":{"lvl1":"Software and its Engineering","lvl6":"Class Diagram","lvl5":"Diagrams","lvl4":"Unit Design","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"content":"\\,\n\nA class diagram \n\nUnified Modeling Language, v2.5.1, 2017, containing a collection of blocks and their\nrelationships, similar to a block diagram. However, in a class diagram, the blocks are functional\nsubunits of a unit. Each block contains a set of data members followed by a set of functional\nmembers. In an object aware language, such as Python or Java, a block might directly correspond to a\nclass in the language sense. In an imperative language, such as C, the blocks may correspond to one\nor more .c or .h files.\n\nEach member of the class is decorated to indicate public or private visibility, meaning, visibility\nto the world outside the unit. A + is used to indicate public visibility, meaning the member can\nbe seen and used by other classes, and a - to indicate private visibility, meaning the member can\nonly be seen from inside the class. When referencing other units in the system, the external units\nare truncated to an empty class (as in the Card class in \n\nFigure 6a). One or more optional\ndecorators can be added to a class to further contextualize the class. The decorators that we allow\nin a class diagram are:\n\nEnumeration: Indicating the class is an enumeration.\n\nInterface: Indicating the class is an interface. This is usually used to simplify the diagram\nwhen common collections of data/functions need to be repeated.\n\nExternal: Indicating the class is defined outside the current unit.\n\nThe relationships between classes are described by arrows between those classes. Each type of arrow\nused in a class diagram defines a slightly different type of relationship. The arrows that we will\nallow in a class diagram are the aggregation (\n\nFigure 6a) and the realization (\n\nFigure 6b).\nThe aggregation connection describes the relationship when one class uses (aggregates) the connected\nclass. In \n\nExample 7, a class diagram for a Go Fish player, we see the Player class using\n(aggregating) the Hand class. In \n\nFigure 6b we see the realization connection, which\ndescribes the relationship when a class implements an interface. An example can be seen in\n\n\nExample 7 with the Hand and Book classes realizing the CardCollection interface.\nBoth the Hand and Book classes are collections of multiple cards and will need common data, such\nas a function to print all cards in the collection. This common (expected) data is modeled as an\ninterface that can be reused without needing to be rewritten.\n\nNote\n\nIn some object-oriented languages, this relationship may be defined by an\ninterface or with inheritance. However, in languages that are not\nobject oriented\nsuch as C, we instead define this common set of data as an abstract interface\nfor design purposes that we must implement in each component that realizes the\ninterface.\n\nclassDiagram\n    A *--B\n\n(a)An aggregation connection. Class A aggregates Class B.\n\nclassDiagram\n    A ..|> B\n\n(b)A realization connection. Class A realizes Class B.\n\nA class diagram for a Go Fish player.\n\nclassDiagram\n    class Player{\n        +Hand hand\n        +List[Book] books\n        +get_score()\n        +go_fishing()\n        +check_card_in_hand()\n        -count_books()\n        -make_books()\n    }\n    class Hand{\n    }\n    class Book{\n    }\n    class Card{\n    <<External>>\n    }\n    class CardSuit{\n        <<External Enumeration>>\n    }\n    class CardCollection{\n        <<External Interface>>\n    }\n    Book *-- Card\n    Player *-- Hand\n    Player *-- Book\n    Hand *-- Card\n    Card *-- CardSuit\n    Hand ..|> CardCollection\n    Book ..|> CardCollection","type":"content","url":"/software#class-diagram","position":27},{"hierarchy":{"lvl1":"Software and its Engineering","lvl6":"State Machine","lvl5":"Diagrams","lvl4":"Unit Design","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"type":"lvl6","url":"/software#state-machine","position":28},{"hierarchy":{"lvl1":"Software and its Engineering","lvl6":"State Machine","lvl5":"Diagrams","lvl4":"Unit Design","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"content":"A state machine \n\nUnified Modeling Language, v2.5.1, 2017 diagram describes the collection of states and\ntransitions that a function can move between. When defining a state machine, we start with two\nspecial states. The first special state is the start state, indicated by a filled in circle, and the\nsecond special state is the end state, indicated by a filled in circle surrounded by a ring. Other\nstates are recorded by a box with text describing the state. Decision points are documented with a\ndiamond, with each path of the condition decorated with text.\n\nA state machine diagram for Go Fish turn\n\nstateDiagram-v2\n    select: Select player to ask for a card\n    fish: Ask player for a card\n    match: Group hand into books\n    rc: Receive a card\n    dac: Draw card from deck\n    state has_card <<choice>>\n\n    [*] --> select\n    select --> fish\n    fish --> has_card\n    has_card --> dac: Target player does not have card\n    has_card --> rc: Target player has card\n    dac --> match\n    rc --> match\n    match --> [*]\n\nA book is the matched sets of cards that are counted at the end of Go Fish to determine the\nwinner.\n\n","type":"content","url":"/software#state-machine","position":29},{"hierarchy":{"lvl1":"Software and its Engineering","lvl4":"Implementation","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"type":"lvl4","url":"/software#implementation","position":30},{"hierarchy":{"lvl1":"Software and its Engineering","lvl4":"Implementation","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"content":"Once the design of a unit is complete, we are ready to implement (program) that unit. There are no\nspecial activities in the implementation phase outside of programming effort. It is important to\nstrictly follow the unit and system design in this phase. If deficiencies in design are found, the V\nmodel allows for that feedback to be pushed to earlier phases and addressed by flowing back through\nthe V model. Good practice in the programming stage is to add a comment describing each unit\nimplementation as well as each data an functional memeber. The goal of these comments is to briefly\ndescribe the code for future readers, but they cannot replace the written documentation from\nprevious sections. Additional good practices are to consistently format the code with a common\nstyle, utilize good data hygiene with a version control system, and favor simple implementations\nover “clever”.\n\n","type":"content","url":"/software#implementation","position":31},{"hierarchy":{"lvl1":"Software and its Engineering","lvl4":"Unit Testing","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"type":"lvl4","url":"/software#unit-testing","position":32},{"hierarchy":{"lvl1":"Software and its Engineering","lvl4":"Unit Testing","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"content":"With implementation complete, we move to the right side of the V, which consists of the verification\nactivities. The first verification phase is the isolated verification of each unit, called unit\ntesting. In this phase, we design and carry out tests of the units we have implemented. When\ndesigning tests, it is important to draw from the unit design directly, instead of designing tests\nagainst the actual implemented code. Testing the code against the design ensures that we are not\ndrawing the target around the arrow. Tests, particularly unit tests, can and should, be separated\ninto two classes of tests. The first class is those on the “happy path”, validating that “good”\nwell-formed input generates expected output, see \n\nExample 9. The second class are those on the\n“unhappy path”, validating that “bad” or malformed input is handled as expected, see\n\n\nExample 10. Each public, accessible to external units, interface of a unit should have at\nleast one unit test. If validation in this, or the following phases, finds deficiencies in the\ndesign, the V model allows for that feedback to be pushed to earlier phases and addressed by flowing\nback through the V model.","type":"content","url":"/software#unit-testing","position":33},{"hierarchy":{"lvl1":"Software and its Engineering","lvl5":"Test Cards","lvl4":"Unit Testing","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"type":"lvl5","url":"/software#test-cards","position":34},{"hierarchy":{"lvl1":"Software and its Engineering","lvl5":"Test Cards","lvl4":"Unit Testing","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"content":"As we walk up the right side of the V, instead of diagrams we utilize test cards. A test card is\nused to define a set of requirements that a test will be implemented against. Each test card has\nfour fields with content as follows:\n\nTest Name: The unique name for the test. This name is used in test reports to identify what\nhas failed.\n\nDescription: The description of what the test is validating and how that validation works.\nThis section may include text and diagrams.\n\nInputs: A set of inputs to feed the unit.\n\nOutputs: The outputs that are expected when the inputs are fed to the unit.\n\nThe following are two examples of unit test cards for the Go Fish product. One test card is on the\nhappy path, and one is on the unhappy path.\n\nA happy path test card for a player turn in Go Fish\n\nTest Card: Request A Card, Reponse Is Positive\n\nDescription: Active player requests a card from a target player. The target\nplayer has the requested card and produces it.\n\nInputs:\n\nA valid requested card\n\nA valid target player with requested card in hand\n\nOutputs:\n\nActive player puts the received card in hand\n\nA unhappy path test card for a player turn in Go Fish\n\nTest Card: Illegally Request A Card\n\nDescription: Active player requests a card that is not in their hand.\n\nInputs:\n\nAn invalid requested card\n\nOutputs:\n\nActive player is notified the request failed","type":"content","url":"/software#test-cards","position":35},{"hierarchy":{"lvl1":"Software and its Engineering","lvl4":"Integration Testing","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"type":"lvl4","url":"/software#integration-testing","position":36},{"hierarchy":{"lvl1":"Software and its Engineering","lvl4":"Integration Testing","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"content":"While working in software, it is rare for a system to have a single unit or a collection of units\nthat are completely uncoupled (\n\nDefinition 3). When we do have units that depend on each other, we\ncall the process of sticking those units together, integration. We verified during the unit\ntests that implemented units work individually as expected. In the integration testing phase, we\nverify that implemented units work together as expected. Tests in this phase should be designed\nagainst the artifacts from the software design phase (\n\nSection 7.1.3.2) as well as the use\ncases defined in the requirements phase (\n\nSection 7.1.3.1).","type":"content","url":"/software#integration-testing","position":37},{"hierarchy":{"lvl1":"Software and its Engineering","lvl4":"Acceptance Testing","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"type":"lvl4","url":"/software#acceptance-testing","position":38},{"hierarchy":{"lvl1":"Software and its Engineering","lvl4":"Acceptance Testing","lvl3":"Software Engineering and Life Cycle","lvl2":"Basics of Product Management and Software Engineering"},"content":"When we have completed unit and integration testing, we have verified that the software, based on\nthe design, doesn’t unexpectedly break and satisfies written requirements (use cases). However, we\nhave not yet verified that the system satisfies what all stakeholders wanted. In our Go Fish\nexample, this phase may include a presentation to a customer. This is the point where a customer may\nfind that our interpretations of \n\nExample 1 disagree, and we update to \n\nExample 2.\n\nAt the time of writing “Python for Everybody” by the University of Michigan is a great choice.\n\nA collection of quality goals that need to be satisfied to call a step “complete”.\n\nResearch Experiences for Undergraduates, a program funded by the National Science Foundation\n(NSF). prettier-ignore-start ","type":"content","url":"/software#acceptance-testing","position":39},{"hierarchy":{"lvl1":"Software and its Engineering","lvl2":"Survey of Knot Theory Software Tools"},"type":"lvl2","url":"/software#sec-surveyoftools","position":40},{"hierarchy":{"lvl1":"Software and its Engineering","lvl2":"Survey of Knot Theory Software Tools"},"content":" prettier-ignore-end \n\nHaving now established a model process for developing software we can start our efforts in\ndeveloping a design for a general knot theory software toolbox. To begin, we explore a collection of\ntools currently in use in the computational knot theory space. Considering the strengths and\nshortcomings of these tools helps inform the requirements and possible use cases for our general\nknot theory software toolbox.","type":"content","url":"/software#sec-surveyoftools","position":41},{"hierarchy":{"lvl1":"Software and its Engineering","lvl3":"KnotPlot","lvl2":"Survey of Knot Theory Software Tools"},"type":"lvl3","url":"/software#knotplot","position":42},{"hierarchy":{"lvl1":"Software and its Engineering","lvl3":"KnotPlot","lvl2":"Survey of Knot Theory Software Tools"},"content":"KnotPlot\n\nScharein, 1998 is a closed source knot computation\ntool primarily and widely used for diagramming knots, this includes several diagrams in this thesis.\nKnotPlot was developed as a portion of Dr. Robert Scharein’s PhD thesis\n\n\nScharein, 1998, he is also the primary maintainer. The primary\ninterface for KnotPlot is by interacting with a GUI. This makes the onboarding process for\nnon-technical users, including undergraduate researchers, straightforward and the learning curve\nshallow. KnotPlot includes many export options and specialized research computational tools, some\nundocumented. While support is readily available from Dr. Scharein this can make power use of\nKnotPlot difficult. KnotPlot has recently added a programmatic interface allowing general scripting\nin the programming language Lua. This scripting interface allows for custom diagramming and custom\ncomponents. These custom scripts are limited however by the hooks available in KnotPlot. It is not\nalways clear what calls to make into KnotPlot to accomplish your goals. Additionally, since the Lua\ninterface is compiled into KnotPlot and isn’t a language widely used in research, finding supported\nexternal libraries can be difficult. KnotPlot is an unparalleled knot diagramming tool, but the\nenvironment becomes a walled garden that can be difficult to build into a tool chain.","type":"content","url":"/software#knotplot","position":43},{"hierarchy":{"lvl1":"Software and its Engineering","lvl3":"Mathematica Libraries","lvl2":"Survey of Knot Theory Software Tools"},"type":"lvl3","url":"/software#mathematica-libraries","position":44},{"hierarchy":{"lvl1":"Software and its Engineering","lvl3":"Mathematica Libraries","lvl2":"Survey of Knot Theory Software Tools"},"content":" (Mathematica https://katlas.org/wiki/Printable_Manual) \n\nKnotTheory \n\nBar-Natan, n.d. and LinKnot \n\nJablan & Sazdanović, 2007 are collections of knot\ntheory tools and datasets that are used with the Wolfram Mathematica system. Both KnotTheory and\nLinKnot are open source and available for download. Mathematica is a natural environment for\nmathematics research, as the language syntax is similar to written theoretical mathematics. This\nsimilarity of appearance lowers the learning curve for use of the tooling. Mathematica is also\ncommonly used in undergraduate calculus sequences, making the onboarding of undergraduate\nresearchers straight forward. The interfaces defined by both KnotTheory and LinKnot are natural in\nthe Mathematica context, further shallowing the learning curve for those already familiar with\nMathematica. Additionally, both collections are well documented by the website “knot atlas”\n\n\nBar-Natan, n.d. and the textbook “LinKnot” \n\nJablan & Sazdanović, 2007 for KnotTheory and\nLinKnot, respectively. Unfortunately, neither collection is under active development or maintenance,\nwith the last published versions from 2016 for KnotTheory and 2011 for LinKnot. Additionally,\nneither collection is released under version control, has a bug log, or has a published test suite.\nMissing the traceability implicit in these artifacts makes program correctness something that must\nbe considered when using the collections. prettier-ignore-start ","type":"content","url":"/software#mathematica-libraries","position":45},{"hierarchy":{"lvl1":"Software and its Engineering","lvl3":"SnapPy/SnapPea","lvl2":"Survey of Knot Theory Software Tools"},"type":"lvl3","url":"/software#sec-surveyoftools-snap","position":46},{"hierarchy":{"lvl1":"Software and its Engineering","lvl3":"SnapPy/SnapPea","lvl2":"Survey of Knot Theory Software Tools"},"content":" prettier-ignore-end \n\nSnapPy \n\nCuller et al., n.d. is a Python wrapper for SnapPea, which is a collection of C libraries. SnapPy and\nSnapPea are open source and published in the same GitHub repository which includes bug reporting and\ntest suites. SnapPy’s Python bindings allow researchers to leverage the massive Python ecosystem,\nallowing for wide and varied usage. SnapPy can be utilized in anything such as a simple command line\ntool, GUI tool to draw knots, or a web application doing knot computations. This allows SnapPy to be\ntailored to the needs of individual researchers, allowing for simple subsets of functionality to be\npresented to undergraduate researchers. Each of these uses benefits from the decoupling of SnapPy\nand the core logic in SnapPea, allowing for fast execution of the SnapPea C code, but simple\nsupportable Python bindings. The SnapPea layer, however, is designed on an ad hoc basis, meaning\neach file/unit stands alone with little structural overlap. If a developer wants to reuse the\nSnapPea C layer directly, they must reverse engineer the structures they wish to reuse.\n\nClosed source software is a software product with no published source code.\n\nA graphical user interface, such as a Windows or the screen on a copy machine.\n\nOpen-source software is a software product with publicly published source code. prettier-ignore-start ","type":"content","url":"/software#sec-surveyoftools-snap","position":47},{"hierarchy":{"lvl1":"Software and its Engineering","lvl2":"Architecture of A Knot Theory Software Toolbox"},"type":"lvl2","url":"/software#sec-archofktst","position":48},{"hierarchy":{"lvl1":"Software and its Engineering","lvl2":"Architecture of A Knot Theory Software Toolbox"},"content":" prettier-ignore-end \n\nIn \n\nSection 7.2 we discussed prior art in the knot computation space, in this section we\nutilize that analysis to design a software architecture for a general knot theory software toolbox.\nTo complete this design, we will execute the first two phases of the modified V model we developed\nin \n\nSection 7.1.3.","type":"content","url":"/software#sec-archofktst","position":49},{"hierarchy":{"lvl1":"Software and its Engineering","lvl3":"Requirements","lvl2":"Architecture of A Knot Theory Software Toolbox"},"type":"lvl3","url":"/software#requirements","position":50},{"hierarchy":{"lvl1":"Software and its Engineering","lvl3":"Requirements","lvl2":"Architecture of A Knot Theory Software Toolbox"},"content":"In this section we carry out the requirements phase of the modified V model. We will create a set of\nrequirements and use cases that model the expectations we have for a general knot theory software\ntoolbox. First, we would like our system to be easy to use. As we saw, easy to use can encompass\nvarious possibilities. We can capture all of these possibilities by decoupling the theoretical\nfunctionality from the user interfaces, and instead we will implement specific interfaces for\nspecific users.\n\nRequirement: User Interface Goals\n\nThe system shall not couple functionality to user interface.\n\nThis design goal allows the interface to be a Jupyter notebook during undergraduate knot theory\nclass, a Mathematica library for research, or a tool run on a university cluster for\nhigh-performance needs. With any possible target environment as a goal, the system must not be\ncoupled to a particular platform (Windows, Linux, etc.), informing our second requirement.\n\nRequirement: Portability Goals\n\nThe system shall be platform (OS, language, toolchain, I/O (Input\nand Output)) agnostic.\n\nThe tools we saw in \n\nSection 7.2 are all what we may call monolithic, meaning, from a\ndevelopment perspective, if the tool is to be used as a part in a new system, the whole tool must be\nincluded. In general, it is preferable to include only the functionality a system actually requires.\nFor example, consider a system is being built to teach a seminar on constructing the Jones\npolynomial. That system will need to include a Jones polynomial component. Needing to pull in at the\nsame time a hyperbolic volume component that serves no purpose, needlessly increasing the complexity\nof the system. These extensibility goals inform an encapsulation design goal.\n\nRequirement: Encapsulation Goals\n\nSystem use cases shall be encapsulated into feature components.\n\nEncapsulating each feature allows for the system components to be used by developers to build\nprojects or products. However, as we saw in our discussion of SnapPy (\n\nSection 7.2.3),\nencapsulation itself does not remove all difficulty in reuse. We can further lower the difficulty of\nreuse by increasing commonality between components without coupling the components. This is\naccomplished by ensuring that every system component adheres to a set of common design patterns.\n\nRequirement: Pattern Goals\n\nSystem use cases shall adhere to a set of design patterns.\n\nFinally, we can further reduce the overhead of reuse we enforce a common development process on\nsystem components.\n\nRequirement: Documentation Goals\n\nSystem use cases shall be documented and planned as outlined by the modified V\nmodel (\n\nSection 7.1.3).\n\nWe now develop a collection of use cases that address the high-level behaviors expected by the\ngeneral knot theory software toolbox.\n\nUse Case: Use The Software\n\nA user interacts with the system.\n\nUse Case: Data Is Manipulated\n\nData in the system is manipulated into something different.\n\nUse Case: Data Is Created\n\nNew data in the system is created.\n\nUse Case: Data Is Written\n\nData is written down for future use.\n\nflowchart LR\n\n    player[\"User fa:fa-user\"]\n    P1([Use the software])\n    P2([Data is manipulated])\n    P3([Data is created])\n    P4([Data is written])\n    player --> P1\n    P1 -. include .-> P2\n    P1 -. include .-> P3\n    P2 -. include .-> P4\n    P3 -. include .-> P4\n\nA use case diagram for the listed use cases. prettier-ignore-start ","type":"content","url":"/software#requirements","position":51},{"hierarchy":{"lvl1":"Software and its Engineering","lvl3":"Software Design","lvl2":"Architecture of A Knot Theory Software Toolbox"},"type":"lvl3","url":"/software#sec-system-design","position":52},{"hierarchy":{"lvl1":"Software and its Engineering","lvl3":"Software Design","lvl2":"Architecture of A Knot Theory Software Toolbox"},"content":" prettier-ignore-end \n\nWith a set of requirements for our design, we can now describe a software design. Each requirement\ncan be partitioned into one of two classes of requirements, functional or non-functional. Where, a\nfunctional requirement can impact the implementation of code and a non-functional requirement\ncannot. We start by addressing a software design for the non-functional requirements:\n\nUser Interface Goals\n\nPortability Goals\n\nDocumentation Goals\n\nThe user interface goal is satisfied by simply excluding any user interface design from the\nsoftware. The portability goal tells us that we need to pick a technology stack that is supported on\nthe maximal number of platforms. The clear choice is to implement the software in the C language.\nThe C language is widely used, and a C compiler exists to target just about any platform. The\nfollowing is a selection of C compilers and tool chains and their targets:\n\nCython \n\nBehnel et al., 2011: “Cython is a Python compiler that makes writing C extensions for\nPython as easy as Python itself. Cython is based on Pyrex, but supports more cutting edge\nfunctionality and optimizations.” - Cython Documentation\n\nGNU\n\nGCC, the GNU Compiler Collection, 2025: A C compiler that can has around 200 targets including\n\nx86_64\n\nARM\n\nMotorola 68000\n\nPowerPC\n\nEmscripten \n\nZakai, 2011: Compiles C to WebAssembly\n\n\nW3C, 2022 allowing for C code to be used in web systems.\n\nEmbedded compilers: Various compilers for esoteric embedded systems.\n\nSelecting C for an implementation language has some risks, primarily caused by the\nlow-level nature of C. As a low-level language, C has no built-in garbage collection\nmechanism, that is, memory can be allocated but is not unallocated automatically. To mitigate this\nrisk in C development we disallow memory allocation in our components. Any memory allocation must\nhappen in the user interface layer, and then buffers with known sizes shall be passed to the\nfunctional components.\n\nTo address the two remaining functional requirements, encapsulation goals and pattern goals, we\ndefine a collection of generic component interfaces that cover common use cases we described in the\nprevious section. We also model these interfaces as a block diagram demonstrating the relationship\nbetween the interfaces.\n\nRunner: The runner interface serves as the stand-in for user interfaces. Since we are decoupling\nthe interface from the functionality, there is no further design consideration for the runner\ninterface.\n\nRunnables: Runnables serve as the functionality that is called by a runner.\n\nComputation: The computation interface is a runnable that operates in a one call, one return\nprogram flow (one thing in one thing out). Example: Compute Jones Polynomial and Compute\nWrithe.\n\nGenerator: The generation interface is a runnable that operates in a one call, multiple return\nflow (one thing in many things out). Example: generate rational tangles, generate Montesinos\ntangles, and generate arborescent tangles.\n\nData Wranglers: Data wranglers serve as a non-user facing layer used by runnables to handle data.\n\nNotation: The notation interface defines data structures used to represent knot data.\nAdditionally, the interface describes the translation between string representations and data\nstructures. Example: Conway notation, algebraic tangle tree notation, and weighted planar\ntangle tree notation.\n\nStorage: The storage interface serves the need for components to read and write from external\nsystems. Examples: the command line or a database.\n\nflowchart LR\n    Runner\n    subgraph \"Runnables\"\n        Generator\n        Computation\n    end\n    subgraph \"Data Wranglers\"\n        Notation\n        Storage\n    end\n    Runner -->|1..*| Generator\n    Runner -->|1..*| Computation\n    Runner -->|1..*| Notation\n    Generator -->|1..*| Notation\n    Computation -->|1..*| Notation\n    Generator -->|1| Storage\n    Computation -->|1| Storage\n\nA block diagram of the architecture of a knot theory software toolbox\n\nAn embedded system is a small, usually low power, computer (microcontroller) that is built into\na product. For example, the power seat of your car is an embedded system.\n\nA low-level language such as C or Rust compiles to machine code that runs directly on the\nhardware. A high-level language is one that abstracts functionality away from hardware.","type":"content","url":"/software#sec-system-design","position":53},{"hierarchy":{"lvl1":"Tabulation"},"type":"lvl1","url":"/tabulation","position":0},{"hierarchy":{"lvl1":"Tabulation"},"content":"","type":"content","url":"/tabulation","position":1},{"hierarchy":{"lvl1":"Tabulation","lvl2":"The First Tangle Datasets"},"type":"lvl2","url":"/tabulation#the-first-tangle-datasets","position":2},{"hierarchy":{"lvl1":"Tabulation","lvl2":"The First Tangle Datasets"},"content":"This chapter will describe the methodology used to answer two of the essential questions detailed in\n\n\nSection 4.3.\n\n“How do I systematically construct rational tangles?”, “How do I tell two rational tangles I make\napart?”, and “How do I generate new rational tangles?”\n\n“How do I systematically construct Montesinos tangles?”, “How do I tell two Montesinos tangles I\nmake apart?”, and “How do I generate new Montesinos tangles?”\n\nThe methodologies outlined in this section are for relatively simple classes of tangles, the\nrational and Montesinos tangles. As we progress, we will see a common solution pattern that outlines\nthe general approach to the more difficult algebraic/arborescent case in \n\nSection 6.2. That\napproach takes the form of the cadence:\n\nDefine the object.\n\nDefine equivalence for the object.\n\nIdentify a unique representation.\n\nGenerate those unique representatives\n\n prettier-ignore-start ","type":"content","url":"/tabulation#the-first-tangle-datasets","position":3},{"hierarchy":{"lvl1":"Tabulation","lvl3":"Rational Tangles","lvl2":"The First Tangle Datasets"},"type":"lvl3","url":"/tabulation#sec-rational","position":4},{"hierarchy":{"lvl1":"Tabulation","lvl3":"Rational Tangles","lvl2":"The First Tangle Datasets"},"content":" prettier-ignore-end \n\nWe will see in this section that rational tangles, originally described by Conway\n\n\nConway, 1970, have a deeply combinatorial nature, making them among the\nsimplest classes of tangle. This simplicity leads to the rational tangles, and their knot closures,\nbeing some of the most commonly studied objects in knot theory.","type":"content","url":"/tabulation#sec-rational","position":5},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Construction","lvl3":"Rational Tangles","lvl2":"The First Tangle Datasets"},"type":"lvl4","url":"/tabulation#construction","position":6},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Construction","lvl3":"Rational Tangles","lvl2":"The First Tangle Datasets"},"content":"In our development of the modified tangle calculus (\n\nSection 5.3.2) we described a way to\nglue tangles together, allowing us to take simple objects and build complex objects. That approach\nforms the basis for our construction of the rational tangles.\n\nWe start, with an intuitive description of the construction. Imagine a zero tangle\n(\n\nFigure 9a), now attach to that tangle a crank on the right (east) side\n(\n\nFigure 1). We allow, for a moment, the fixed points of the tangle to move. If we crank a\nhalf turn clockwise or anti-clockwise, we introduce a twist, if we turn the crank n half turns we\nmake an integral n tangle(\n\nSection 5.3.3).\n\n\n\nFigure 1:A set of three turns, changing a basic 0 tangle into an integral 3 tangle.\n\nWhen we have completed n turns we take the crank and move it to the bottom (south) side of the\ntangle. We turn the crank to add n half turns, this time building a vertical integral tangle.\nContinuing this, alternating between right and bottom sets of half turns, as seen in\n\n\nFigure 2, a rational tangle. For a rational tangle T, the list of counts for\nright and bottom twists is the twist vector (\n\nDefinition 2) of the rational tangle.\n\n\n\nFigure 2:The set of alternating turns building a rational tangle \\LB3\\ 2\\ 1\\RB.\n\nFormalizing this intuitive construction requires the \\vee and + operations\n(\n\nSection 5.3.2), as well as the integral tangles (\n\nSection 5.3.3). This\nformalization was originally stated by Conway \n\nConway, 1970 but was ultimately\nproved by Burde and Zieschang, we will give a later construction by Kauffman and Goldman\n\n\nGoldman & Kauffman, 1997. For convenience, we denote a horizontal integral tangle with a\\in\\Z\ncrossings as t_a, similarly, a vertical integral tangle with b\\in \\Z crossings as t_b^\\prime.\n\nKauffman and Goldman, Page 310 \n\nGoldman & Kauffman, 1997\n\nConway, 1970\n\nTo build a rational tangle, take one of the following constructions:\n\nStart with a horizontal tangle t_{a_0}. Add by \\vee a vertical tangle\nt_{b_0}^{\\prime} on the bottom, then add by + a horizontal tangle\nt_{a_1} on the right, then add by \\vee a t_{b_1}^{\\prime} on the\nbottom, and so on, stopping after a finite number of such steps at a\nhorizontal tangle t_{a_n}.\n\nStart with a vertical tangle t_{b_0}^\\prime. Add by + a horizontal\ntangle t_{a_0} on the right, then add by \\vee a vertical tangle\nt_{b_1}^\\prime on the bottom, then add by + a t_{a_1} on the right, and\nso on, stopping after a finite number of such steps at a\nhorizontal tangle t_{a_n}.\n\nNote\n\nIn the first case the twist vector has an odd number of entries and in the\nsecond the twist vector has an even number of entries.\n\nTo see the alignment between \n\nDefinition 1 and our intuitive construction, view the turning\nof the crank as corresponding to horizontal and vertical integral tangles, and the alternating of\nright and bottom as corresponding to alternating + and \\vee.","type":"content","url":"/tabulation#construction","position":7},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Correspondence With Extended Rational Numbers","lvl4":"Construction","lvl3":"Rational Tangles","lvl2":"The First Tangle Datasets"},"type":"lvl5","url":"/tabulation#correspondence-with-extended-rational-numbers","position":8},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Correspondence With Extended Rational Numbers","lvl4":"Construction","lvl3":"Rational Tangles","lvl2":"The First Tangle Datasets"},"content":"Now we formally address our first two essential questions by:\n\nDescribing a notation for rational tangles.\n\nDemonstrating a correspondence between the rational tangles and the extended rational numbers.\n\nShowing that the correspondence distinguishes (tells apart) rational tangles.\n\nThe answer to our first essential question, “How do I systematically construct rational tangles?”,\nis seen by formalizing the twist vector notational strategy we saw in our intuitive formulation for\nrational tangles. This allows us to systematically write down a rational tangle by a list of\nintegers.\n\nConway Page 332\n\nConway, 1970\n\nGoldman & Kauffman, 1997\n\nThe list of integers of the sets of tangles t_{a_i} and t_{b_j}^\\prime\nfrom \n\nDefinition 1 ordered as \n\n(1) or\n\n\n(2) is called a\ntwist vector.    \\LB a_0\\ b_0\\ a_1\\ b_1\\ \\cdots\\ a_n\\RB    \\LB b_0\\ a_0\\ b_1\\ \\cdots\\ a_n\\RB\n\nWe are now ready to answer the second of the essential questions, “How do I tell two rational\ntangles I make apart?” The critical observation to answer the questions is due to Conway’s use\n\n\nConway, 1970 of the entries of a twist vector as the entries for a continued\nfraction (\n\nDefinition 3). Since the twist vector is of finite length, this continued fraction\ncorresponds to an extended rational number \n\nRockett & Szüsz, 1998, \\Q\\cup\\LS\\infty\\RS.\n\nConway, Page 332\n\nConway, 1970\n\nFor a rational tangle T we call \n\n(3) the fraction of a\nrational tangle and denote it F\\LP T\\RP.    \\frac{p}{q} = a_{n} + \\cfrac{1}{b_n + \\cfrac{1}{a_n + \\cfrac{1}{b_{n-1} +\n    \\cfrac{1}{a_{n-1} + \\cfrac{1}{\\ddots\\,+\\cfrac{1}{a_0}}}}}}\n\nNote\n\nThe correspondance with the extended rational numbers means that\nF\\LP\\LB1\\ \\m 1\\ 0\\RB\\RP=\\frac{1}{0} corresponds to the basic \\infty tangle\n(\n\nFigure 12a).\n\nKauffman and Goldman \n\nGoldman & Kauffman, 1997 prove (\n\nTheorem 1) that this\ncorrespondence distinguishes, tells apart, rational tangles. Meaning, given two rational tangles, if\ntheir fractions are the same the tangles are isotopic, and if the fractions are different, the\ntangles are not isotopic. This answers the second of our essential questions.\n\nConway’s Theorem, Kauffman and Goldman page 315\n\nConway, 1970\n\nBurde et al., 2013\n\nGoldman & Kauffman, 1997\n\nLet T_1 and T_2 be rational tangles. F\\LP T_1\\RP=F\\LP T_2\\RP if and only\nif T_1 is ambient isotopic to T_2.\n\nObserve, \n\nTheorem 1 does not discount the possibility of two non-equivalent twist\nvectors, those differing in at least one entry, representing the same rational tangle.\n\n\nExample 1 demonstrates that the possibility is true. In fact, for each rational\ntangle, the set of twist vectors representing it is infinite.\n\n\\begin{aligned}\nF\\LP\\LB 1\\ 7\\ 0\\ 1\\RB \\RP &= \\frac{9}{1}\\\\\\\\\nF\\LP\\LB \\m 3\\ 1\\ \\ \\m 1\\ \\m 1\\ \\m 1\\ 1\\ 9\\RB \\RP &= \\frac{9}{1}\\\\\\\\\nF\\LP\\LB 1\\ \\m1\\ 1\\ \\m1\\ 7\\ 0\\ 3\\RB \\RP &= \\frac{9}{1}\\\\\\\\\nF\\LP\\LB 1\\ \\m1\\ \\m1\\ 1\\ \\m1\\ 1\\ \\m1\\ 1\\ \\m1\\ 9\\RB \\RP &= \\frac{9}{1}\\\\\\\\\nF\\LP\\LB 1\\ 8\\RB \\RP &= \\frac{9}{1}\\\\\\\\\nF\\LP\\LB 9\\RB \\RP &= \\frac{9}{1}\\\\\\\\\n\\end{aligned}\n\nTo effectively answer our third essential question, “How do I generate rational tangles?”, we will\nneed to determine a unique twist vector representative for each rational tangle. A unique\nrepresentative allows us to simply and efficiently write down each tangle without risk of duplicates\nshowing up on our list.","type":"content","url":"/tabulation#correspondence-with-extended-rational-numbers","position":9},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Canonical Twist Vectors","lvl3":"Rational Tangles","lvl2":"The First Tangle Datasets"},"type":"lvl4","url":"/tabulation#canonical-twist-vectors","position":10},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Canonical Twist Vectors","lvl3":"Rational Tangles","lvl2":"The First Tangle Datasets"},"content":"Identifying a unique representative will stem from properties of finite continued fractions. We\nstart by defining a specific subclass of finite continued fractions with integer coefficients, the\nregular continued fractions. We frame the definition in the context of twist vectors.\n\nKauffman and Goldman, page 318\n\nKauffman & Lambropoulou, 2002\n\nRockett & Szüsz, 1998\n\nA continued fraction with integer coefficients c_i is called a regular\ncontinued fraction if c_i< 0 for every coefficient or 0< c_i for\nevery coefficient except the last which may be 0.\n\nConveniently, each extended rational number corresponds to exactly two regular continued fractions\n\n\nRockett & Szüsz, 1998. The first is a twist vector with the leftmost element greater than\nor equal to 2, and the second with leftmost element equal to 1, per \n\n(5).\nObserve, one of these twist vectors has an even number of entries, and one has an odd number of\nentries.\\begin{aligned}\n    F\\LP\\LB 9\\RB \\RP &= \\frac{9}{1}= 8+\\frac{1}{1} = F\\LP\\LB 1\\ 8\\RB \\RP \\\\\n    F\\LP\\LB 9\\ 0\\RB \\RP &= 0+\\frac{1}{9}=0+\\frac{1}{8+\\frac{1}{1}}=\n    F\\LP\\LB 1\\ 8\\ 0\\RB \\RP \\\\\n\\end{aligned}\n\nNote\n\nThe fraction \\frac{1}{0} corresponds to the \\LB 0\\ 0\\RB twist vector.\n\nTo identify a unique representative for a rational number and hence rational tangle, we will select,\nfor convenience, the odd length twist vector as our unique representative.\n\nKauffman and Lambropoulou, Page 13 \n\nKauffman & Lambropoulou, 2002\n\nA twist vector is called a canonical twist vector if it contains\ncoefficients of a regular continued fraction and is of odd length or is\n\\LB0\\ 0\\RB.","type":"content","url":"/tabulation#canonical-twist-vectors","position":11},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Computational Methods","lvl3":"Rational Tangles","lvl2":"The First Tangle Datasets"},"type":"lvl4","url":"/tabulation#computational-methods","position":12},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Computational Methods","lvl3":"Rational Tangles","lvl2":"The First Tangle Datasets"},"content":"Armed with a unique representative for a rational tangle, we can construct our computational answer\nto the third essential question.","type":"content","url":"/tabulation#computational-methods","position":13},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Notation","lvl4":"Computational Methods","lvl3":"Rational Tangles","lvl2":"The First Tangle Datasets"},"type":"lvl5","url":"/tabulation#notation","position":14},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Notation","lvl4":"Computational Methods","lvl3":"Rational Tangles","lvl2":"The First Tangle Datasets"},"content":"We start by describing how we will digitally store a rational tangle. In the rational tangle case,\nthe theoretical encoding strategy of twist vectors happens to be well suited for computational\nstorage. A twist vector can be computationally stored identically to its written form, a list of\nspace separated integers delimited by a pair of square braces, \\LB\\ \\RB. As we will see in\n\n\nSection 6.2 this direct translation of theoretical notation to computational notation is not\nalways the case.","type":"content","url":"/tabulation#notation","position":15},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Generation","lvl4":"Computational Methods","lvl3":"Rational Tangles","lvl2":"The First Tangle Datasets"},"type":"lvl5","url":"/tabulation#generation","position":16},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Generation","lvl4":"Computational Methods","lvl3":"Rational Tangles","lvl2":"The First Tangle Datasets"},"content":"A common tactic in the knot tabulation space is to pare down the number of items that must be\ntabulated by leveraging symmetries of the objects being tabulated. For example, the \\LB 3\\RB and\n\\LB \\m 3\\RB tangles are related to each other by a minus operation (\n\nMinus Tangle).\nMeaning, if we tabulate \\LB 3\\RB, we can recover \\LB \\m 3\\RB with multiplication by \\m 1. This\nfact holds for all rational tangles as demonstrated by \n\nLemma 1. Allowing us to focus our\nefforts on the rational tangle with twist vectors containing only positive entries.\n\nKauffman and Lambropoulou, Page 19\n\nKauffman & Lambropoulou, 2002\n\nFor a tangle T with negative -T (\n\nMinus Tangle), if\nF\\LP T\\RP=\\frac{p}{q} then F\\LP \\m T\\RP=\\m\\frac{ p}{q}.\n\nWe now begin our development of a generation strategy for twist canonical twist vectors of rational\ntangles. The method seen here utilizes a common combinatorial method for defining compositions of\nintegers, the same is used for rational tangle counting by Bryhtan\n\n\nBryhtan, 2024. Consider, for a given crossing number n, what is the most\n“obvious” twist vector? A viable candidate for most “obvious” is a twist vector, of the form seen in\n\n\n(6), dropping the trailing 0 where needed.\\LB 1\\ 1\\ 1\\ \\cdots\\ 1\\RB\n\nThe 1’s twist vector \n\n(6) is an ideal starting point for developing a generation\nstrategy, as it distributes the data of a rational tangle as broadly as possible. Next, we consider\nhow we might transform the 1’s twist vector into a twist vector with a two crossing integral\ncomponents. We can do this by exchanging the space between the first and second 1 with a numeric\n+.\\begin{aligned}\n&\\LB 1\\square 1\\ 1\\ \\cdots\\ 1\\RB\\\\\\\\\n&\\LB 1+1\\ 1\\ \\cdots\\ 1\\RB\\\\\\\\\n&\\LB 2\\ 1\\ \\cdots\\ 1\\RB\\\\\\\\\n\\end{aligned}\n\nThis process tells us that we can utilize the exchange of whitespace of a twist vector for + to\ngenerate new twist vectors. To complete our generation, we must generate every combination of\nexchanges.\n\nThe 1’s twist vector with crossing number n has n 1s and n-1 spaces. In each space position,\nwe have the option between a space and +. To enumerate all 2^{n-1} combinations, we can simply\ncount, in binary, from 1 to 2^{n-1}, as in \n\nExample 2.\n\nCombinations of exchanges for n=4 and their twist vector\\begin{aligned}\n000\\to \\square \\square \\square\\to &\\LB1\\ 1\\ 1\\ 1\\RB \\\\\\\\\n001\\to \\square \\square +\\to &\\LB1\\ 1\\ 2\\RB \\\\\\\\\n010\\to \\square + \\square\\to &\\LB1\\ 2\\ 1\\RB \\\\\\\\\n011\\to \\square + +\\to &\\LB1\\ 3\\RB \\\\\\\\\n100\\to + \\square \\square\\to &\\LB2\\ 1\\ 1\\RB \\\\\\\\\n101\\to + \\square +\\to &\\LB2\\ 2\\RB \\\\\\\\\n110\\to + + \\square\\to &\\LB3\\ 1\\RB \\\\\\\\\n111\\to + + +\\to &\\LB4\\RB \\\\\\\\\n\\end{aligned}\n\nOur final refinement in this process it to transform this collection into canonical twist vectors.\nHalf of the twist vectors, those of odd length, generated in this process are already canonical. To\ncanonize the even length twist vectors, we append 0 to the right most position of each list,\nturning the even vectors into an odd canonical vectors.\n\nNote\n\nAppending 0 to the even twist vectors makes each of the fractions for these\ntwist vectors sit in the unit interval, \\LB 0,1\\RP.\n\nWe conclude the section with a set of algorithms that describe a method for computationally\ngenerating all rational tangles up to a given crossing number.\n\nFind all rational tangles of crossing number n\n\nInput\n\nA crossing number n\n\nOutput\n\nAll collection T of twist vectors\n\nRoutine\n\nGenerate O the 1’s twist vector as in \n\n(6) for n\n\nfor i=0 to 2^{n-1}\n\nTransform i into its binary representation\n\nExchange as in \n\n(7) digits of i with spaces where i\nis O and with + where i is 1\n\nApply operations to the 1s vector and store the resulting vector as O_r\n\nIf O_r is odd length, store O_r in T\n\nElse, append 0 to O_r and store\n\nFind all rational tangles up to crossing number n\n\nInput\n\nA crossing number n\n\nOutput\n\nAll collection T of twist vectors\n\nRoutine\n\nStore the twist vectors \\LB 0\\RB,\\LB 0\\ 0\\RB,\\LB 1\\RB\n\nfor i=2 to n\n\nExecute \n\nAlgorithm 1 with i\n\n prettier-ignore-start ","type":"content","url":"/tabulation#generation","position":17},{"hierarchy":{"lvl1":"Tabulation","lvl3":"Montesinos Tangles","lvl2":"The First Tangle Datasets"},"type":"lvl3","url":"/tabulation#sec-monttang","position":18},{"hierarchy":{"lvl1":"Tabulation","lvl3":"Montesinos Tangles","lvl2":"The First Tangle Datasets"},"content":" prettier-ignore-end \n\nIn this section, we will use the rational tangles to build a yet more complex class of tangles, the\nMontesinos tangles. This building up process demonstrates one of the core strategies for tangle\ntabulation.","type":"content","url":"/tabulation#sec-monttang","position":19},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Construction","lvl3":"Montesinos Tangles","lvl2":"The First Tangle Datasets"},"type":"lvl4","url":"/tabulation#construction-1","position":20},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Construction","lvl3":"Montesinos Tangles","lvl2":"The First Tangle Datasets"},"content":"With the rational tangles in hand, we wish to utilize that data to enumerate additional tangles. One\nway we have seen to build simple objects into complex objects is to combine two tangles with the +\nor \\vee operation. To keep complexity under control, we start with combining tangles with repeated\n+ sum. When all summands, R_i in equation \n\n(9), are rational, we call the result of\nthe sum a Montesinos Tangle \n\nErnst, 1996\n\nBonahon & Siebenmann, 2016.R_0+R_1+\\cdots+R_n\n\nNote\n\nUnder this characterization of the Montesinos tangles, every rational tangle\nincluding the integral tangles are Montesinos tangles with a single summand.","type":"content","url":"/tabulation#construction-1","position":21},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Unique Representative","lvl4":"Construction","lvl3":"Montesinos Tangles","lvl2":"The First Tangle Datasets"},"type":"lvl5","url":"/tabulation#unique-representative","position":22},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Unique Representative","lvl4":"Construction","lvl3":"Montesinos Tangles","lvl2":"The First Tangle Datasets"},"content":"Next, we develop a classification of Montesinos tangles, allowing us to tell two Montesinos tangles\napart. For each rational summand R_i in a Montesinos tangle, we have four possibilities:\n\nR_i’s canonical twist vector is positive and ends in 0\n\nR_i’s canonical twist vector is positive and does not end in 0\n\nR_i’s canonical twist vector is negative and ends in 0\n\nR_i’s canonical twist vector is negative and does not end in 0\n\nObserve that in the second and fourth cases, R_i terminates in a horizontal integral tangle. In\nthese cases, the tangle can be simplified by using the flype (\n\nThe Flype) to move the\nhorizontal crossings to be the right most summand, seen in \n\nFigure 3. When this process\nis carried out for each summand of the type in cases two and four, the resulting summands all fall\ninto cases one and three.\n\n\n\nFigure 3:A Montesinos tangle\n\n\\LB1\\ 2\\ 2\\RB+\\LB \\m1\\ \\m2\\ 0\\RB+\\LB \\m3\\ \\m2\\ \\m1\\RB+\\LB 1\\ 2\\ 0\\RB+\\LB1\\ 2\\ 2\\RB\n\nsimplifying to\\LB 1\\ 2\\ 0\\RB+\\LB \\m 1\\ \\m 2\\ 0\\RB+\\LB \\m3\\ \\m 2\\ 0\\RB+\\LB1\\ 2\\ 2\\RB+\\LB1\\ 2\\ 0\\RB+\\LB 3\\RB\n\nWe will now pare down to a single possibility, case one. Consider a summand R_i in case three,\nmeaning \\m 1 <F\\LP R_i\\RP<0 except for R_n, which may be integral. \n\nTheorem 1 tells\nus that if we can find an alternative, potentially non-canonical, twist vector that fits our needs,\nwe are free to exchange without impacting topology. What we would like is an odd length twist\nvector, where every entry is positive, except for the rightmost, which is a negative value, see\n\n\nFigure 4.\n\n\n\nFigure 4:On the left rational tangle \\LB \\m1\\ \\m2\\ \\m1\\ \\m1\\ 0\\RB and on the right\n\\LB 3\\ 2\\ \\m1\\RB. These tangles have fractions\nF\\LP\\LB \\m1\\ \\m2\\ \\m1\\ \\m1\\ 0\\RB\\RP=\\frac{\\m4}{7} and\nF\\LP\\LB 3\\ 2\\ \\m1\\RB\\RP=\\frac{\\m4}{7} showing the tangles to be isotopic.\n\nThis ensures that the fraction is still negative but will allow us to flype the terminal horizontal\nintegral tangle to the right. Rockett and Szüusz give a lemma that establishes the existence of such\na twist vector for each rational number.\n\nRockett and Szüsz, Page 3 \n\nRockett & Szüsz, 1998\n\nEvery extended rational number has a continued fraction with positive integer entries\nexcept for the first (rightmost twist vector entry) which is an integer.\n\nWe have now shown that each case (2,3,4) can be transformed into the first case, and we can define a\ncanonical form for Montesinos tangles.\n\nBonahon and Siebenmann, Theorem 11.7 \n\nBonahon & Siebenmann, 2016\n\nEvery non-rational Montesinos tangle T admits a canonical diagram satisfying\nthe following construction:T \\cong R_0+\\cdots+R_m+\\frac{k}{1}\n\nwhere each R_i \\cong \\frac{p_i}{q_i} is a rational subtangle in canonical form with\nfraction satisfying 0<\\frac{p_i}{q_i}<1, and \\frac{k}{1} is a horizontal\ninteger subtangle.","type":"content","url":"/tabulation#unique-representative","position":23},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Computational Methods","lvl3":"Montesinos Tangles","lvl2":"The First Tangle Datasets"},"type":"lvl4","url":"/tabulation#computational-methods-1","position":24},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Computational Methods","lvl3":"Montesinos Tangles","lvl2":"The First Tangle Datasets"},"content":"","type":"content","url":"/tabulation#computational-methods-1","position":25},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Notation","lvl4":"Computational Methods","lvl3":"Montesinos Tangles","lvl2":"The First Tangle Datasets"},"type":"lvl5","url":"/tabulation#notation-1","position":26},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Notation","lvl4":"Computational Methods","lvl3":"Montesinos Tangles","lvl2":"The First Tangle Datasets"},"content":"Before we can generate Montesinos tangles, we need to define an efficient notation for computation\nand storage. Similar to what we saw in the rational tangle case, the theoretical notation for\nMontesinos tangles is sufficient for computation. However, with eyes on future computational work,\nwe will generalize our notation to increase reusability and the efficiency of storage.\n\nMontesinos tangles are simple forms of the algebraic tangles (\n\nDefinition 7), so we will build a\nnotational strategy for general algebraic tangles. The strategy seen here is similar to those found\nin Conolly, Caudron , and Gren, Sulkowska, and, Gabrovšek\n\n\nConnolly, 2021\n\nCaudron, 1982\n\nGren et al., 2025.\nThe theoretical notation for algebraic tangles is outlined in \n\nSection 5.3.2 and seen in\n\n\nExample 3. We can simplify the notation, without losing fidelity, by substituting the integral\nleaf tangles for rational tangle twist vectors. Additionally, we can improve the storage overhead by\nstoring the tree as a string in Polish notation \n\nŁukasiewicz, 1929.\nStoring in Polish notation allows us to drop all the parentheses from our notation, saving two bytes\nin each instance.\n\n\n\nAlgebraically:\\LB1\\ 2\\ 0\\RB+\\LP\\LB2\\ 1\\ 0\\RB+\\LB2\\ 2\\ 0\\RB\\RP\n\nIn polish notation:+\\LB1\\ 2\\ 0\\RB+\\LB2\\ 1\\ 0\\RB\\LB2\\ 2\\ 0\\RB\n\nAs an algebraic tangle tree:   flowchart TD\n   id0(\"+\")-->id1(\"[1 2 0]\")\n   id0-->id2\n   id2(\"+\")-->id3(\"[2 1 0]\")\n   id2-->id4(\"[2 2 0]\")","type":"content","url":"/tabulation#notation-1","position":27},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Generation","lvl4":"Computational Methods","lvl3":"Montesinos Tangles","lvl2":"The First Tangle Datasets"},"type":"lvl5","url":"/tabulation#generation-1","position":28},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Generation","lvl4":"Computational Methods","lvl3":"Montesinos Tangles","lvl2":"The First Tangle Datasets"},"content":"In this section, we will design an algorithm that allows us to efficiently generate new Montesinos\ntangles up to a given crossing number. As we saw, the construction of a Montesinos tangle is based\non the repeated summation of rational tangles. Consequently, our generation strategy will utilize\nour table of rational tangles.\n\nTo start, we need a mechanism that allows us to select all possible combinations of rational tangles\nwith crossing numbers that sum to our target. For a Montesinos tangle T, the set of rational\ncomponents \\LS R_i\\RS_i^n combined with the integral component k corresponds to an ordered list\nof crossing numbers as in \n\n(10).CN\\LP R_0\\RP,\\ \\cdots,\\ CN\\LP R_n\\RP,\\  CN\\LP k\\RP\n\nWe call a list of the form seen in \n\n(10) a stencil for a Montesinos tangle. By\nconstruction, every canonical Montesinos tangle relates to precisely one stencil. Observe, that\n2\\leq CN\\LP R_i\\RP since \\frac{1}{2} is the lowest crossing number rational tangle with fraction\nin the unit interval.\n\nGeneration for all Montesinos tangles of a given crossing number at this point can be broken down\ninto two steps:\n\nGenerate all stencils\n\nFill in the stencils with all rational tangles of the appropriate crossing number whose fraction\nis in the unit interval (plus an integral tangle in the rightmost position)\n\nFor the first step, we require a mechanism for breaking an integer into all possible combinations\nwhere the parts sum to the integer. Luckily, we have already seen how to do this, in the context of\na twist vector. We follow the same counting algorithm outlined in \n\nAlgorithm 1 however, we\nmodify the algorithm to keep both the even and odd outputs, but filter out stencils with entries\nless than two.\n\nThe set of all possible stencils for crossing number 5:\n\n\n\n\n\n\n\n\n\n1\\ 1\\ 1\\ 1\\ 1\n\n2\\ 1\\ 1\\ 1 \n\n1\\ 2\\ 1\\ 1\n\n1\\ 1\\ 2\\ 1\n\n1\\ 1\\ 1\\ 2 \n\n3\\ 1\\ 1 \n\n1\\ 3\\ 1 \n\n1\\ 1\\ 3 \n\n2\\ 2\\ 1 \n\n2\\ 1\\ 2 \n\n1\\ 2\\ 2 \n\n3\\ 2 \n\n2\\ 3 \n\n4\\ 1 \n\n1\\ 4 \n\n5 \n\n\\!\\,The set of stencils for crossing number 5:\n\n\n\n\n\n3\\ 2\n\n2\\ 3\n\nFor the second step, for each entry in the stencil we create a list of rational tangles in the unit\ninterval with that entry for a crossing number. For the rightmost entry of the stencil we also\ninclude the horizontal integral tangles with crossing number equal entry. This creates all\ncombinations of input tangles given by the stencil.\n\nThe set of rational tangles of crossing numbers two and three:\n\nTwo\n\nThree\n\n[1\\ 1\\ 0]\n\n[2\\ 1\\ 0] \n\n[2] \n\n[1\\ 2\\ 0] \n\n\n\n[3] \n\nThe set of stencils for crossing number five, with rational tangles inserted :\n\n3\\ 2\n\n2\\ 3\n\n+[2\\ 1\\ 0][1\\ 1\\ 0] \n\n+[1\\ 1\\ 0][2\\ 1\\ 0] \n\n+[1\\ 2\\ 0][1\\ 1\\ 0] \n\n+[1\\ 1\\ 0][1\\ 2\\ 0] \n\nWe conclude the section with a set of algorithms that describe this method for computationally\ngenerating all Montesinos tangles up to a given crossing number.\n\nFind all stencils of crossing number n\n\nInput\n\nA crossing number\n\nOutput\n\nAll collection S stencils\n\nRoutine\n\nGenerate O the 1’s twist vector as in  \n\n(6) for n\n\nfor i=0 to 2^{n-1}\n\nTransform i into its binary representation\n\nExchange as in \n\n(7) digits of i with spaces where i\nis O and with + where i is 1\n\nApply operations to the 1s vector and store the resulting vector as O_r\n\nContinue to the next iteration if O_r has entries less than 2\n\nAdd O_r to S\n\nFind all Montesinos tangles of crossing number n\n\nInput\n\nAll rational tangles of crossing number up to n\n\nOutput\n\nAll collection T of Montesinos tangles\n\nRoutine\n\nExecute \n\nAlgorithm 3 for n and store in S\n\nfor each stencil s in in S\n\nRetrieve lists L=\\LS L_i\\RS_i^n of rational tangles for each stencil\nentry s_i.\n\nAdd to the L_n list the integral tangle s_n\n\nWhile there is a list in L that is not exhausted.\n\nConstruct and store a Montesinos tangle from list entries.\n\nFind all Montesinos tangles up to crossing number n\n\nInput\n\nA crossing number\n\nAll rational tangles up to n\n\nOutput\n\nAll collection T of twist vectors\n\nRoutine\n\nfor i=4 to n\n\nExecute \n\nAlgorithm 4 with i\n\nEach tangle can be represented by an infinite number of diagrams. A unique representative in\nthis context means a particular “flavor” of diagram that exists for every tangle in the class we\nare concerned about.\n\n prettier-ignore-start ","type":"content","url":"/tabulation#generation-1","position":29},{"hierarchy":{"lvl1":"Tabulation","lvl2":"Arborescent Tangles"},"type":"lvl2","url":"/tabulation#sec-arborescent","position":30},{"hierarchy":{"lvl1":"Tabulation","lvl2":"Arborescent Tangles"},"content":" prettier-ignore-end \n\nThis section describes the methodology we use to answer the final of the essential questions\ndetailed in \n\nSection 4.3.\n\n“How do I systematically construct algebraic/arborescent tangles?”, “How do I tell two\nalgebraic/arborescent tangles I make apart?”, and “How many algebraic/arborescent tangles can I\ncreate?”\n\nIn this thesis so far we have worked with the algebraic tangles (\n\nDefinition 7) constructed with\nConway’s tangle arithmetic (\n\nOperations on Tangles).\n\nIn this section we will leverage a slightly different, but equivalent, construction given by Bonahon\nand Siebenmann \n\nBonahon & Siebenmann, 2016 the arborescent tangles. The one-to-one\ncorrespondence between the classes will become clear as we introduce the construction for\narborescent tangles.\n\nThis section starts with an overview of Bonahon and Siebenmann’s\n\n\nBonahon & Siebenmann, 2016 definition of arborescent knots and tangles\n(\n\nSection 6.2.1). We then give their smooth and combinatorial constructions of arborescent knots\nand tangles (\n\nSection 6.2.2). Next, we give original work extending Bonahon and Siebenmann’s canonical\nconstruction to a local view (\n\nSection 6.2.2.4). This local view is leveraged to define a unique\nrepresentative for each class of arborescent tangles (\n\nSection 6.2.3). Finally, we will describe an\noriginal algorithm and notation that directly enumerates those unique representatives\n(\n\nSection 6.2.4). prettier-ignore-start ","type":"content","url":"/tabulation#sec-arborescent","position":31},{"hierarchy":{"lvl1":"Tabulation","lvl3":"Definition of Arborescent","lvl2":"Arborescent Tangles"},"type":"lvl3","url":"/tabulation#prelim-arbor-def","position":32},{"hierarchy":{"lvl1":"Tabulation","lvl3":"Definition of Arborescent","lvl2":"Arborescent Tangles"},"content":" prettier-ignore-end \n\nWe now give a high-level description of the manifold theory underpinning the theory of arborescent\nknots and tangles. A full treatment of the manifold theory can be found in Bonahon and Siebenmann\n\n\nBonahon & Siebenmann, 2016. Our first concept is that of a knot pair, which serves as\nthe underlying structure for all the smooth objects in this subsection.\n\nBonahon and Siebenmann, Page 15 \n\nBonahon & Siebenmann, 2016\n\nA knot pair is a pair (M, K) where M is an oriented connected compact 3\nmanifold with (possibly empty) boundary, and where K is a proper 1-dimensional\nsubmanifold of M.\n\nBonahon and Siebenmann, Page vi \n\nBonahon & Siebenmann, 2016\n\nA knot (S^3, K) is arborescent if there exists a finite collection\nF_1,\\dots,F_n of disjoint Conway spheres such that, if N is the closure (in the sense of a closure of a set) of\nany component of S^3 − \\cup_{i=1}F_i , then the pair (N, K \\cap N ) takes the\nsimple form of \n\nFigure 5 after suitable isotopic\ndeformation in S^3.\n\n\n\nFigure 5:A collection of Conway circles forming what we call an\narborescent vignette.\n\n\n\n(a)The arborescent vignette from \n\nFigure 5 seen with Conway spheres.\n\n\n\n(b)The arborescent vignette showing a 1 crossing tangle to be arborescent.\n\nFigure 6:Arborescent vignettes.\n\nNote\n\nThe F_i in \n\nDefinition 7 are disjoint but may sit inside\neach other. This means we may have arborescent vignettes containing arborescent\nvignettes, but the closure of each individual component looks like\n\n\nFigure 5.\n\nObserve that arborescent knots are characterized by a collection of Conway spheres (circles).\nChoosing to not fill one, or more, of these Conway spheres yields a tangle.\n\nBonahon and Siebenmann, Page 144 \n\nBonahon & Siebenmann, 2016\n\nDefine an arborescent tangle as one whose underlying knot pair (M, K) (\n\nDefinition 6) is\narborescent in the sense defined in \n\nDefinition 7.\n\nWe see from the above the first portion of the correspondence between the algebraic and arborescent\ntangles. Each algebraic tangle can be naturally decomposed into a collection of nested arborescent\nknot vignettes given by its operations + and \\vee.\n\n prettier-ignore-start ","type":"content","url":"/tabulation#prelim-arbor-def","position":33},{"hierarchy":{"lvl1":"Tabulation","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl3","url":"/tabulation#subsec-wptt","position":34},{"hierarchy":{"lvl1":"Tabulation","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":" prettier-ignore-end \n\n prettier-ignore-start  prettier-ignore-end  prettier-ignore-start ","type":"content","url":"/tabulation#subsec-wptt","position":35},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Construction of Arborescent Knots from Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl4","url":"/tabulation#construction-of-arbor","position":36},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Construction of Arborescent Knots from Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":" prettier-ignore-end \n\nThis subsection begins with an introduction to Bonahon and Siebenmann’s\n\n\nBonahon & Siebenmann, 2016 construction of arborescent knots and tangles in the smooth\nsetting. This is followed by the development of a combinatorial representation for arborescent knots\nand tangles \n\nBonahon & Siebenmann, 2016. We deviate slightly from Bonahon and Siebenmann’s\nintroduction but ultimately arrive at the same structure. In our introduction we develop partial\nsolutions, then progressively modify those partial solutions until they fit our needs. Next, we\ndescribe Bonahon and Siebenmann’s \n\nBonahon & Siebenmann, 2016 operations on the\ncombinatorial structure, which allow us to systematically modify the structure without changing the\ntopology. This subsection finishes with the classification of arborescent knots and tangles given by\nBonahon and Siebenmann \n\nBonahon & Siebenmann, 2016 as well as our extension from a global\nto local viewpoint.","type":"content","url":"/tabulation#construction-of-arbor","position":37},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Bands and Plumbing Squares","lvl4":"Construction of Arborescent Knots from Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl5","url":"/tabulation#bands-and-plumbing-squares","position":38},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Bands and Plumbing Squares","lvl4":"Construction of Arborescent Knots from Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":"Our first step in describing a notation for the arborescent knots\n\n\nBonahon & Siebenmann, 2016 is describing a plumbing operation on bands. A band with a\nplumbing square is a band S^1\\times\\LB 0,1\\RB, along with an oriented square on the band such that\ntwo of the sides of the square intersect the boundary of the band. Two examples of bands with\nplumbing squares can be seen in \n\nFigure 7.\n\n\n\n(a)A band with a plumbing square facing the viewer.\n\n\n\n(b)A band with the plumping square facing away from the viewer. We are looking through the band.\n\nFigure 7:Plumbing squares of bands.","type":"content","url":"/tabulation#bands-and-plumbing-squares","position":39},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Plumbing bands","lvl4":"Construction of Arborescent Knots from Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl5","url":"/tabulation#plumbing-bands","position":40},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Plumbing bands","lvl4":"Construction of Arborescent Knots from Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":"We now glue the bands seen in \n\nFigure 7 together with an operation called\nplumbing. Consider the orientation given in the green band’s plumbing square. We will call the\nblue arrow X and the thicker red arrow Y; similarly for the blue band with X^\\prime and\nY^\\prime. We plumb the bands together along their plumbing squares, with the requirement that\nthe orientation labels are mapped X\\to Y^\\prime and Y\\to X^\\prime. Finally, we forget the\nboundaries of the plumbing squares, leaving only the joined boundaries of the bands. The result of\nplumbing as well as a local picture for plumbing can be seen in \n\nFigure 8.\n\n\n\n(a)Plumbed bands\n\n\n\n(b)Plumbed bands\n\nFigure 8:Two bands plumbed.\n\nOur plumbing band construction can be turned into a knot by adding a series of half-twists to our\nplumbing bands (\n\nFigure 9a and \n\nFigure 9b). When forming the half twists, we have\ntwo options for direction relative to the band, we call one positive (left handed twists) and one\nnegative (right handed twists). We note that the twists appear in unique regions of the band,\ndetermined by their position relative to the plumbing squares.\n\n\n\n(a)Band with two negative half twists and three plumbing squares.\n\n\n\n(b)Band with three positive half twists and one plumbing square.\n\nFigure 9:Plumbing bands with twists.\n\nSuccessive plumbing yields collections of bands like those seen in \n\nFigure 10a. Finally,\nturning \n\nFigure 10a into a knot is as simple as removing the interior of the band, leaving\nonly the boundary, per \n\nFigure 10b.\n\n\n\n(a)Bands plumbed\n\n\n\n(b)An arborescent knot.\n\nFigure 10:A set of plumbed bands in\n\n\nFigure 10a\nand arborescent knot in \n\nFigure 10b\n\nIt is important to note that, for creating arborescent knots, we must restrict plumbing from\ncreating “cycles” of bands. That is a chain of plumbing beginning and ending with the same band, as\nseen in \n\nFigure 11. If we allow cycles in the bands, we may create a polygonal tangle,\ndefined in \n\nTangle insertions. These polygonal tangles contain portions that do not satisfy\n\n\nDefinition 8, so are not arborescent presentations.\n\n\n\nFigure 11:A collection of bands plumbed in such a way that the last band is plumbed to\nthe first band in a cycle.\n\nWe now establish some language for describing the relative positions of bands. This language will be\nreused when we transition to the combinatorial setting and is widely used in graph theoretic\nsettings.\n\nGiven a band B with plumbing squares, we call the set C of bands\nplumbed to B the children of B. Additionally, for c\\in C, we call B\nthe parent of c and the collection of C-\\LS c \\RS the\nsiblings of C.\n\nWe claim the plumbing band construction is in correspondence with the definition of arborescent seen\nin \n\nDefinition 7. To see this, we take each plumbing band and encapsulate it in a\nS^2 so that the corners of the plumbing squares lie on the S^2, giving us the vignette seen in\n\n\nFigure 6a.","type":"content","url":"/tabulation#plumbing-bands","position":41},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Weighted Planar Trees","lvl4":"Construction of Arborescent Knots from Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl5","url":"/tabulation#weighted-planar-trees","position":42},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Weighted Planar Trees","lvl4":"Construction of Arborescent Knots from Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":"The band construction we have developed for arborescent knots, as it stands, is completely unsuited\nfor machine computation. In this subsection, we lay out a line of reasoning leading to a\ncombinatorial encoding strategy \n\nBonahon & Siebenmann, 2016 for the plumbing band\nconstruction of arborescent knots and tangles. The line of reasoning starts by presenting the\nrequired data of arborescent knots and tangles that any combinatorial representation must encode. We\nthen propose partial solutions, each progressively closer to the full encoding described by Bonahon\nand Siebenmann \n\nBonahon & Siebenmann, 2016. As we will see, the encoding strategy\nultimately takes the form of a modified rooted plane tree, a specialized flavor of graph theoretic\ntree.\n\nInventing a combinatorial encoding strategy means we first have to identify the essential\ninformation that is needed to construct arborescent knots and tangles from band plumbings. The two\nessential pieces of information that must be encoded by any combinatorial strategy for notating\nplumbing of bands are the following:\n\nThe parent child relationship between bands\n\nThe twists on bands, and their positions relative to the band’s children (plumbing squares)\n\nExplicit details expanding on why these two pieces of information are essential can be found in\nBonahon and Siebenmann \n\nBonahon & Siebenmann, 2016. We will see in the following\nsubsections ways in which these data are essential, albeit in specialized cases.\n\nConsider the first piece of essential information our combinatorial strategy must encode, the parent\nchild relationships between bands. Perhaps the most commonly computationally utilized structure that\nencodes relational data is an abstract graph. We imagine how an abstract graph might be used for\nencoding the relationship of bands. One solution is to map bands to vertices and plumbing\nrelationships to edges. In the discussion of the band construction, we restricted plumbing from\nforming cycles (\n\nFigure 11). A result of this restriction is that any abstract graph\nmust also have no cycles, meaning all the graphs we will work with, abstract or otherwise, are\nactually trees. We will call the data of a vertex and a collection of bonds (half-edges)\nassociated with plumbing squares the local picture around a vertex.\n\nWe have partially completed our goal of encoding the essential information of band plumbing in a\ncombinatorial object. Unfortunately, an abstract tree doesn’t encode all the essential data.\nParticularly, our second piece of information, the positions of children and weights, is not easily\nseen in an abstract tree. To solve this problem, we will instead use a modified version of an\nabstract tree, a rooted plane tree, for our encoding.\n\nA rooted plane tree is an abstract tree imbued with a strict total order,\nindexed by the non-negative integers, on the vertices. We call the least\nvertex the root of the tree.\n\nIn a rooted plane tree \\Gamma, at each vertex v, the children of v have an ordering inherited\nfrom the total order of \\Gamma, we call this ordering of the children the cyclic order of the\nchildren. The cyclic order gives us two natural ways to draw v and its children in the plane. We\nmay choose to draw the children anti-clockwise in one of increasing or decreasing order of index.\nThe realization of these two options can be seen in \n\nFigure 12. A universal choice\nof increasing or decreasing yields a unique realization of a rooted plane tree in the plane.\n\n\n\n(a)The local picture of a vertex with child labels increasing in anti-clockwise order.\n\n\n\n(b)The local picture of a vertex with child labels decreasing in anti-clockwise order.\n\nFigure 12:\\, prettier-ignore-start ","type":"content","url":"/tabulation#weighted-planar-trees","position":43},{"hierarchy":{"lvl1":"Tabulation","lvl6":"Indexing the total order of a tree","lvl5":"Weighted Planar Trees","lvl4":"Construction of Arborescent Knots from Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl6","url":"/tabulation#indexing-rpt","position":44},{"hierarchy":{"lvl1":"Tabulation","lvl6":"Indexing the total order of a tree","lvl5":"Weighted Planar Trees","lvl4":"Construction of Arborescent Knots from Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":" prettier-ignore-end \n\nWe will now describe an ideal indexing for a rooted plane tree.\n\nLet \\Gamma be a rooted plane tree and r be the root of \\Gamma. Additionally,\nlet v_i\\neq r be a vertex with parent v_p and children\nv_{c_1},\\,\\cdots,\\,v_{c_n}. We call the indexing of a rooted plane ideal if\nit satisfies the following:\n\nr is index 0\n\np<i<c_1<\\cdots< c_n\n\nNote\n\nTwo commonly seen orderings of a tree are the breadth and depth\nfirst orderings, both orderings\nare ideal orderings. For our purposes we will prefer the depth first ordering.\n\n\n\n(a)A rooted plane tree with ideal indexing. The index of each vertex is seen inside the vertex.\n\n\n\n(b)A rooted plane tree with indexing that is not ideal. The index of each vertex is seen inside the vertex.\n\nFigure 13:Indexing strategies of a rooted plane tree.\n\nFor the remainder of this thesis we will adopt some conventions for\nrooted plane\ntrees (and their derivatives the weighted planar tangle trees, CWPTT, and\nRLITT). When realizing a tree in the plane we select the universal\nanti-clockwise increasing\norder and assume that the tree has depth first indexing.\n\nThe final data we need to record is the position and count of half twists relative to plumbing\nsquares. We observed earlier that the half twists on a band must lie in a unique region determined\nby position relative to plumbing squares on a band. This relationship can be recreated for a rooted\nplane tree by annotating the local view of a vertex with an integer placed in the regions between\nbonds. The relationship between a plumbing band and a weighted vertex in a rooted plane tree can be\nseen in \n\nFigure 14a. The weights placed in regions between bonds inherit a cyclic order from\nthe cyclic order of the bonds. Each weight falls in the region between two bonds. We assign to each\nweight (including zero weights) the lower of the two indices. This aligns with assigning to the\nweight the index that appears before it in the anti-clockwise planar realization of the cyclic\norder, per \n\nFigure 14b.\n\n\n\n(a)The local view of a vertex with the weights two, zero, and zero.\n\n\n\n(b)The local view of a vertex with weight. Notice the index of the weights comes from the bond\n“before” it in the planar realized cyclic order.\n\nFigure 14:Local view of a vertex with weights.\n\nWe can see a full example of a tree with its associated plumbed construction in\n\n\nFigure 15a. We call this fully realized combinatorial recipe for an arborescent knot a\nweighted planar tree.\n\nBonahon and Siebenmann, Page 143\n\nBonahon & Siebenmann, 2016\n\nA rooted plane tree \\Gamma augmented with weights is called a\nweighted planar tree.\n\n\n\n(a)The tree describing the plumbing of bands. Each vertex represents the band illustrated near it.\n\n\n\n(b)The realization by plumbing bands of the tree in \n\nFigure 15a\n\nFigure 15:Realization of plumbing of a tree. prettier-ignore-start ","type":"content","url":"/tabulation#indexing-rpt","position":45},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Weighted Planar Tangle Trees","lvl4":"Construction of Arborescent Knots from Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl5","url":"/tabulation#wpt-construc-sec-wptt","position":46},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Weighted Planar Tangle Trees","lvl4":"Construction of Arborescent Knots from Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":" prettier-ignore-end \n\nOur construction to this point has been concerned with the notation for knots and links. We now give\na modification of this notation for tangles. A weighted planar tree, as in \n\nFigure 17a, can\nbe modified to represent a tangle by allowing a free bond (half-edge) to be attached to a\nvertex, that is, to allow bands to have a non-plumbed plumbing square. We realize the non-plumbed\nsquare as a Conway circle for a two string tangle as in \n\nFigure 17b. To\nconsistently orient the Conway sphere’s interior, we align the north boundary points of the Conway\nsphere with the top (up in the band orientation) boundary component and place the NW corner first\n(following the orientation of the boundary), per \n\nFigure 16. Plumbing two\nbands then corresponds to the action of gluing a pair of tangles together on their Conway spheres so\nthat boundary points align.\n\n\n\nFigure 16:The orientation of a\nConway sphere is given by a plumbing square on a band of an\narborescent tangle. The orientation of the underlying plumbing\nsquare is shown.\nThis aligns with a left hand rule with Y the thumb, X the\nindex finger, and\nZ middle finger, with Z pointing away from the center of the band,\nout of the page in this case.\n\nA tree may have many free bonds, with each free bond representing a unique boundary Conway sphere.\nEach boundary component serves as a location where a tangle can be inserted to form a knot or link.\nFor our efforts in enumerating two string tangles, we restrict our focus to trees that have a single\nfree bond. In tangle trees with a single free bond, we designate the vertex with the free bond as\nthe root of the tree.\n\n\n\n(a)The plumbing realization of an arborescent tangle.\n\n\n\n(b)With an isotopy of the tangle and inversion of the Conway circle given by the\nnon-plumbed square we have the realization of \n\nFigure 17a as a\ntraditional orthogonally projected tangle.\n\nFigure 17:Plumbing bands as a tangle.\n\nWe will see that keeping track of the location of the fixed points of the boundary sphere is\nimportant when determining tangle equivalence. This is due to the need to maintain the rational\nnumber (\n\nDefinition 3) associated with the “rational tangle” subtangles of a tree, prompting us\nto assign rotation information to the free bonds. This information takes the form of labels from the\nmembers of V_4 of the Klein four-group \\iota,\\xi,\\zeta,\\eta. Each of these labels corresponds to\na rotation of the Conway sphere around an axis in \\R^3, as seen in \n\nFigure 18\nand \n\nFigure 19. Full details for the manifold theory underpinning these markings are\nfound in Bonahon and Siebenmann \n\nBonahon & Siebenmann, 2016. We call such a labeled tree a\nweighted planar tangle tree.\n\n\n\n(a)The identity rotation (no rotation)\n\n\n\n(b)The effect of the V_4 rotations on each of the\n\nFigure 18:The identity rotation (no rotation) and the effect of the V_4 rotations on each of the\n\nBonahon and Siebenmann Page 165 \n\nBonahon & Siebenmann, 2016\n\nA weighted planar tree \\Gamma with free bonds labeled in V_4 is called a\n** weighted planar tangle tree (WPTT)**.\n\n\n\n(a)\\iota for no rotation\n\n\n\n(b)\\xi rotates around the X-axis\n\n\n\n(c)\\eta rotates around the Y-axis\n\n\n\n(d)\\zeta rotates around the Z-axis\n\nFigure 19:Roations of a tangle. prettier-ignore-start ","type":"content","url":"/tabulation#wpt-construc-sec-wptt","position":47},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Anatomy of a tree","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl4","url":"/tabulation#wpt-construc-sec-subtrees","position":48},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Anatomy of a tree","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":" prettier-ignore-end \n\nIn this subsection, we will describe several portions of weighted planar trees: the ring subtree,\nessential vertex, and the sticks of a tree. prettier-ignore-start ","type":"content","url":"/tabulation#wpt-construc-sec-subtrees","position":49},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Ring subtree","lvl4":"Anatomy of a tree","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl5","url":"/tabulation#wpt-construc-sec-rings","position":50},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Ring subtree","lvl4":"Anatomy of a tree","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":" prettier-ignore-end \n\nWe will now describe the ring subtrees of a weighted planar tree, which locally appear as\n\n\nFigure 20.\n\n\n\nFigure 20:Positive and negative ring subtrees\n\nNow, resolving the plumbing for the positive subtree, we arrive at bands as in \n\nFigure 21.\n\n\n\nFigure 21:Plumbed ring bands\n\nNotice that the boundary of these plumbed bands has three components, as seen in\n\n\nFigure 22.\n\n\n\nFigure 22:Ring boundary\n\nWith an isotopy of the tangle and inversion of the Conway circle given by the non-plumbed square, we\ncan arrange our plumbed bands into the standard tangle projection seen in \n\nFigure 23. This\ntangle projection tells us that the subtree in \n\nFigure 21 is, depending on location of\n\\text{NW}, either the zero or infinity tangle with a ring.\n\n\n\nFigure 23:Ring Tangle prettier-ignore-start ","type":"content","url":"/tabulation#wpt-construc-sec-rings","position":51},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Essential Vertex","lvl4":"Anatomy of a tree","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl5","url":"/tabulation#wpt-construc-sec-essential-verts","position":52},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Essential Vertex","lvl4":"Anatomy of a tree","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":" prettier-ignore-end \n\nWe now classify each vertex into one of two classes, the essential vertices and the non-essential\nvertices.\n\nBonahon and Siebenmann, Page 159\n\nBonahon & Siebenmann, 2016\n\nWe define an essential vertex as any vertex with valence (count of the number of bonds) greater than 3.\n\nBonahon and Siebenmann, Page 159\n\nBonahon & Siebenmann, 2016\n\nA vertex is called non-essential if it has valence (count of the\nnumber of bonds) 0,1,2.\n\nAs an example, consider the vertices seen in \n\nFigure 24.\n\n\n\nFigure 24:A weighted planar tree annotated with essential vertices in orange and\nnon-essential in blue prettier-ignore-start ","type":"content","url":"/tabulation#wpt-construc-sec-essential-verts","position":53},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Sticks of a Tree","lvl4":"Anatomy of a tree","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl5","url":"/tabulation#wpt-construc-sec-sticks","position":54},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Sticks of a Tree","lvl4":"Anatomy of a tree","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":" prettier-ignore-end \n\nThe final part of the anatomy of a tree we will consider is the sticks of a tree.\n\nBonahon and Siebenmann, Page 159\n\nBonahon & Siebenmann, 2016\n\nLet \\Gamma be a weighted planar tree and \\LS b_i\\RS be the set of essential\nvertices of \\Gamma including their bonds (half-edges). We call the\n\\Gamma_s=\\Gamma\\setminus \\LS b_i\\RS the sticks of \\Gamma and every\nconnected component of \\Gamma_s a stick.\n\nAs an example, consider the tree seen in \n\nFigure 24, the sticks of which can be seen in\n\n\nFigure 25.\n\n\n\nFigure 25:Sticks of the tree from \n\nFigure 24, six half-open sticks and one open\nstick.\n\nBy construction, a stick subtree of \\Gamma may have 0, 1, or 2 free bonds (seen in\n\n\nFigure 26). We call a stick with 0 free bonds closed, 1 free bond half-open, and 2\nfree bonds open. Additionally, we call a stick where each vertex has a single weight a proper\nstick, and we call a vertex on the end of a stick an end vertex.\n\n\n\nFigure 26:From top to bottom, a closed, half-open, and an open stick. Each end vertex\nis colored in red. prettier-ignore-start ","type":"content","url":"/tabulation#wpt-construc-sec-sticks","position":55},{"hierarchy":{"lvl1":"Tabulation","lvl6":"Integral Tangles","lvl5":"Sticks of a Tree","lvl4":"Anatomy of a tree","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl6","url":"/tabulation#wpt-construc-sec-integral","position":56},{"hierarchy":{"lvl1":"Tabulation","lvl6":"Integral Tangles","lvl5":"Sticks of a Tree","lvl4":"Anatomy of a tree","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":" prettier-ignore-end \n\nWhen a weighted planar tangle tree is a half-open stick containing a single vertex with a single\nweight w_0 we call it an integral tangle tree.\n\n\n\nFigure 27:A stick realized as an integral tangle. prettier-ignore-start ","type":"content","url":"/tabulation#wpt-construc-sec-integral","position":57},{"hierarchy":{"lvl1":"Tabulation","lvl6":"Rational Tangles","lvl5":"Sticks of a Tree","lvl4":"Anatomy of a tree","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl6","url":"/tabulation#wpt-construc-sec-rational","position":58},{"hierarchy":{"lvl1":"Tabulation","lvl6":"Rational Tangles","lvl5":"Sticks of a Tree","lvl4":"Anatomy of a tree","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":" prettier-ignore-end \n\nBonahon and Siebenmann \n\nBonahon & Siebenmann, 2016 give a correspondence between stick\ntangle trees (a stick with a single free bond) and Conway’s rational tangles\n\n\nConway, 1970. An example of the correspondence can be seen in\n\n\nFigure 28.\n\n\n\nFigure 28:A stick tangle tree realized as a rational tangle. prettier-ignore-start ","type":"content","url":"/tabulation#wpt-construc-sec-rational","position":59},{"hierarchy":{"lvl1":"Tabulation","lvl6":"Tree Crossing Number","lvl5":"Sticks of a Tree","lvl4":"Anatomy of a tree","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl6","url":"/tabulation#wpt-construc-sec-tcn","position":60},{"hierarchy":{"lvl1":"Tabulation","lvl6":"Tree Crossing Number","lvl5":"Sticks of a Tree","lvl4":"Anatomy of a tree","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":" prettier-ignore-end \n\nFinally, we define the Tree Crossing Number (TCN) of a weighted planar tangle tree. This\ncorresponds to the crossing number of the tangle diagram given by the weighted planar tangle tree.\n\nFor weighted planar tangle tree \\Gamma, with weights \\LS w_i\\RS. We call\\text{TCN}=\\sum |w_i|\n\nthe Tree Crossing Number (TCN).\n\n prettier-ignore-start ","type":"content","url":"/tabulation#wpt-construc-sec-tcn","position":61},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Calculus of Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl4","url":"/tabulation#calculus-on-trees","position":62},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Calculus of Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":" prettier-ignore-end \n\nThis subsection develops a set of moves, F^\\prime_3,\\ F_2,\\ F_1, and R^\\pm, on the weighted\nplanar trees described in \n\nWeighted Planar Tangle Trees. We will restrict our discussion to a subset of the\ncalculus of weighted planar trees. A full description of the calculus can be found in Bonahon and\nSiebenmann \n\nBonahon & Siebenmann, 2016. The F^\\prime_3,\\ F_2,\\ F_1,\\text{ and}\\ R_\\pm\nmoves allow us to systematically modify, without changing the topology, a weighted planar tree and\nform the basis for the classification of the arborescent knots.","type":"content","url":"/tabulation#calculus-on-trees","position":63},{"hierarchy":{"lvl1":"Tabulation","lvl5":"The F^\\prime_3 Move","lvl4":"Calculus of Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl5","url":"/tabulation#the-f-prime-3-move","position":64},{"hierarchy":{"lvl1":"Tabulation","lvl5":"The F^\\prime_3 Move","lvl4":"Calculus of Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":"The first move, and as we will see, the most important in distinguishing tangles, is the\nF_3^\\prime move. In this move we consider the local picture of a vertex. In the local view,\nisolate a single bond (half-edge corresponding to a plumbing square of a band), then move a weight\nacross that bond. The impact of this movement of a weight propagates to the descendants of the\nsubtree attached to the bond (plumbing square) but leaves unchanged all other weights and bonds\n(including their attached subtrees) in the local view of the object vertex.\n\nBonahon and Siebenmann, Section 12.7.3 \n\nBonahon & Siebenmann, 2016\n\nThe F_3^\\prime move on a weighted arborescent tree moves\na weight W as in\n\n\nFigure 29 and, if W is odd,\nreverses the cyclic order of\nweights and bonds at all vertices of the subtree attached to the\npurple bond (half-edge) lying at odd distance\n(count of edges between two vertices) from the vertex shown. Also, when W is\nodd, apply \\xi (X-axis rotation\n\n\nFigure 19) to all free bonds\nin the subtree attached to the purple bond (half-edge) that are\nattached to a vertex at even distance from the\nvertex shown, and \\eta (Y-axis rotation\n\n\nFigure 19c) to those\nat odd distance. The rotations are relative to the local orientations of the\nplumbing squares on the bands corresponding to vertices at odd distance from\nthe vertex carrying weight W.\n\n\n\nFigure 29:An F_3^\\prime move on a subtree. The purple bond indicates the subtree\nimpacted by the move. The blue portion of the local view indicates all other bonds and weights\nof the vertex.\n\nThe F_3^\\prime move is a derivative of the more general F_3 move described in Bonahon and\nSiebenmann \n\nBonahon & Siebenmann, 2016.\n\nBonahon and Siebenmann, Section 12.7.1 \n\nBonahon & Siebenmann, 2016\n\nThe F_3 move replaces the left side of\n\n\nFigure 30 with the right side, where\nthe cyclic order of bonds and weights is reversed at all vertices\nin the subtree attached to the purple bond (half-edge) of the\nvertex shown and at odd distances from this vertex. Also, apply\n\\xi (X-axis rotation) to all free bonds in the subtree attached\nto the purple bond (half-edge) that are attached to a vertex at\neven distance from the vertex shown,\nand \\eta (Y-axis rotation) to those at odd distance. The rotations are\nrelative to the orientation of the  plumbing square (Conway sphere) of the the\nband the weight is moving across, per\n\n\nFigure 16.\n\n\n\nFigure 30:An F_3 move on a subtree. The purple bond indicates the subtree\nimpacted by the move. The blue portion of the local view indicates all other bonds and weights\nof the vertex.\n\nNote\n\nF_3^\\prime is equivalent, in \n\nFigure 30, to\nX=0, then executing F_3 W times, decreasing \\abs{W} with each iteration.\n\nWe will now consider some examples of the F_3^\\prime move. While we explore these examples, we\nview F_3^\\prime from the perspective of an object vertex (object band). The object vertex may have\none or more children that we will act on with F^\\prime_3. When we translate F_3 and F_3^\\prime\ninto practice we are free to operate on children as well as the parent of a vertex (band).","type":"content","url":"/tabulation#the-f-prime-3-move","position":65},{"hierarchy":{"lvl1":"Tabulation","lvl6":"F_3^\\prime on bands","lvl5":"The F^\\prime_3 Move","lvl4":"Calculus of Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl6","url":"/tabulation#f-3-prime-on-bands","position":66},{"hierarchy":{"lvl1":"Tabulation","lvl6":"F_3^\\prime on bands","lvl5":"The F^\\prime_3 Move","lvl4":"Calculus of Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":"The translation of crossings across child bands models the traditional flype move of “Tait\nFlyping Conjecture” \n\nTait, 1900 fame. To see the correspondence between F_3^\\prime and\nflype we need to view the plumbed child (or parent) band as a tangle, T. We can then carry out\nF_3^\\prime over this tangle. Tracking the parts of this operation, we can see the correspondence\nin \n\nFigure 31.\n\n\n\nFigure 31:Flype and F_3^\\prime, with orientation of the Conway sphere given by \n\nWeighted Planar Tangle Trees\n\nWhen this is carried out, for an odd number of crossings, the child band is inverted so it lies\ninside the parent band (\n\nFigure 32). The inversion reverses the cyclic order of the child,\nas described in \n\nDefinition 18.\n\n\n\nFigure 32:The odd F_3^\\prime case on a band model realization of the given portion of a tree, with local\nX-axis in blue and Y-axis in red given relative to the purple band. Yielding a \\xi (X-axis\nrotation) to all bands plumbed to the purple band or plumbed at even distance (counting plumbing\nsquares) from the orange band, and \\eta (Y-axis rotation) to the purple band and those plumbed\nat odd distance from the orange band. Note that the orientations of the plumbing squares must agree\nbefore and after F_3^\\prime. Following the orientations with the left hand\n(Figure~\\ref{wpt-construc-fig-band_orientation}) rule shows the orientation of the purple band\nreverses in X and Z in the second image due to the rotation in Y (we are no longer looking\nthrough the band in the second image).\n\nApplying F_3^\\prime to an even number of crossings is equivalent to applying the move on two sets\nof an odd number of crossings. When the first set of odd crossings is applied, the child band is\ninverted; the second set inverts the child again, leaving it where it began\n(\n\nFigure 33).\n\n\n\nFigure 33:The even case of the F_3^\\prime\nwith the purple band and any descendants of the purple band\nremaining unchanged.\n\nWe expand to an example where the child band has descendants, as in \n\nFigure 34. Observe that\nwhen the F_3^\\prime is applied in this case, the child band and every band even distance from it\n(odd distance from the parent) are inverted.\n\n\n\nFigure 34:F_3^\\prime when applied to a band (gray) with a child (orange) and grandchild (light blue). We\nread the bands following the local orientation of the plumbing squares. Before the move is applied,\nthe child (orange) band is traversed as; the blue band, a green star, a green circle, and back to\nthe parent. After F_3^\\prime it is traversed as; a green circle, a green star, the blue band, and\nback to the parent. The blue band is traversed as; yellow star, yellow circle, and back to orange\nband.","type":"content","url":"/tabulation#f-3-prime-on-bands","position":67},{"hierarchy":{"lvl1":"Tabulation","lvl6":"F_3^\\prime Examples","lvl5":"The F^\\prime_3 Move","lvl4":"Calculus of Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl6","url":"/tabulation#f-3-prime-examples","position":68},{"hierarchy":{"lvl1":"Tabulation","lvl6":"F_3^\\prime Examples","lvl5":"The F^\\prime_3 Move","lvl4":"Calculus of Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":"Consider the weighted planar tree in \n\nFigure 35 and\n\n\nFigure 36, the left trees in each agree in all but a weight of a single\nvertex, what we will call our object vertex which is marked in orange. The weight of this object\nvertex has been changed from -2 in \n\nFigure 35 to -3 in\n\n\nFigure 36.\n\nWe will first walk through \n\nFigure 35. In this example, our object weight is\neven, applying F_3^\\prime to the tree, the impacted subtree (purple subtree in\n\n\nFigure 29) is unchanged except for free bonds, which are altered as described in\n\n\nDefinition 18.\n\n\n\nFigure 35:F_3^\\prime on a weighted planar tree with even weight. The weight of the object weight is even, so\nthe impacted subtree is unchanged.\n\nIn \n\nFigure 36, the object weight is odd, applying F_3^\\prime the cyclic order\nof vertices of the impacted subtree at an odd distance are reversed. Additionally, all free bonds in\nthe impacted subtree are altered as described in \n\nDefinition 18.\n\n\n\nFigure 36:F_3^\\prime on a\nweighted planar tree with odd weight clockwise. Note the\nchanges in the relative positions of subtrees after the application of\nF_3^\\prime.","type":"content","url":"/tabulation#f-3-prime-examples","position":69},{"hierarchy":{"lvl1":"Tabulation","lvl5":"The F_2 Move","lvl4":"Calculus of Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl5","url":"/tabulation#the-f-2-move","position":70},{"hierarchy":{"lvl1":"Tabulation","lvl5":"The F_2 Move","lvl4":"Calculus of Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":"Our second move, F_2, is a special application of the general F_3 move.\n\nBonahon and Siebenmann, Section 12.7.1 \n\nBonahon & Siebenmann, 2016\n\nThe F_2 move on a weighted arborescent tangle tree reverses the cyclic order of bonds and\nweights at one vertex on the tree and at every vertex at even distance from it; also apply \\eta\n(Y-axis rotation) to every free bond of a vertex at even (or zero) distance, and apply \\xi\n(X-axis rotation) to every free bond at odd distance. The rotations are relative to the\norientation of the plumbing square (Conway sphere) of the band being acted on, per\n\n\nWeighted Planar Tangle Trees.\n\nF_2 is equivalent to applying F_3 to a vertex by moving a \\pm 1 weight around a full cycle of\nthe children (and parent), as in \n\nFigure 37a. If the vertex has no weights, the\nzero weight is split into +1 and -1, one of which completes the cycle. The +1 and -1 then\ncancel, returning the vertex to zero weight. The result of carrying out F_2 on a weighted planar\ntree can be seen in \n\nFigure 37b.\n\n\n\n(a)F_3 moving a weight in a complete cycle\n\n\n\n(b)F_2 on a weighted planar tree. Observe the changes to the entire tree, as\nopposed to the changes of F_3^\\prime which impact only a subtree.\n\nF_2 on a WPT\n\nObserve that vertices can be partitioned into two equivalence classes. Those changed by F_2\napplied at an even distance from the root, and those changed by F_2 applied at an odd distance\nfrom the root. We write F_2 on the even class as F_{2e} and odd as F_{2o}.","type":"content","url":"/tabulation#the-f-2-move","position":71},{"hierarchy":{"lvl1":"Tabulation","lvl5":"The F_1 Move","lvl4":"Calculus of Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl5","url":"/tabulation#the-f-1-move","position":72},{"hierarchy":{"lvl1":"Tabulation","lvl5":"The F_1 Move","lvl4":"Calculus of Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":"The third of the F moves is the F_1 move, which is a repeated application of the F_2 move.\n\nBonahon and Siebenmann, Section 12.7.1 \n\nBonahon & Siebenmann, 2016\n\nThe F_1 move on a weighted arborescent tangle tree reverses the cyclic order of bonds and\nweights at every vertex of the graph and applies \\zeta (z-axis rotation) to every free bond. The\nrotations are relative to the orientation of the plumbing square (Conway sphere) of the band being\nacted on, per \n\nWeighted Planar Tangle Trees.\n\nTo realize F_1 as F_2 moves, we successively apply F_{2e} and then F_{2o} to the tree.\nObserve that the combination of F_{2e} and F_{2o} modifies the free bonds by \\xi\\eta=\\zeta.","type":"content","url":"/tabulation#the-f-1-move","position":73},{"hierarchy":{"lvl1":"Tabulation","lvl5":"The R^\\pm moves","lvl4":"Calculus of Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl5","url":"/tabulation#the-r-pm-moves","position":74},{"hierarchy":{"lvl1":"Tabulation","lvl5":"The R^\\pm moves","lvl4":"Calculus of Weighted Planar Trees","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":"The R move, or ring move is the final move we will describe on weighted planar tangle trees and\ndeals with the ring subtrees of a tree. The result of a ring move on a tangle can be seen in\n\n\nFigure 38.\n\n\n\nFigure 38:R^- on on a tangle representation of a tree.\n\nBonahon and Siebenmann, Section 12.3 \n\nBonahon & Siebenmann, 2016\n\nThe R^+ replaces the left of \n\nFigure 40 with the right, leaving the rest of the tree unchanged.\n\n\n\nFigure 39:A \\LP+\\RP-ring subtree moving around a vertex.\n\nBonahon and Siebenmann, Section 12.3 \n\nBonahon & Siebenmann, 2016\n\nThe R^- replaces the left of \n\nFigure 40 with the right, leaving the rest of the tree unchanged.\n\n\n\nFigure 40:A \\LP-\\RP-ring subtree moving around a vertex. Equivalent to \n\nFigure 38.\n\nNote\n\nIn \n\nFigure 38 the ring moves from the right to the left of the\ntangle. This corresponds to the ring subtree in \n\nDefinition 23 moving from\ntop to bottom of the orange portion of the tree.\n\n prettier-ignore-start ","type":"content","url":"/tabulation#the-r-pm-moves","position":75},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Canonical Weighted Planar Tangle Trees (CWPTT)","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl4","url":"/tabulation#sec-cwptt-def","position":76},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Canonical Weighted Planar Tangle Trees (CWPTT)","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":" prettier-ignore-end \n\nObserve that the weighted planar tangle trees we have seen are badly non-unique representatives for\narborescent tangles. The first step to finding a unique preferred representative is to put some\nadditional conditions on a weighted planar tree, \\Gamma. The following conditions pare down the\nequivalence class of an arborescent tangle to a more manageable level.\n\nBonahon and Siebenmann, Section 12.8.2 \n\nBonahon & Siebenmann, 2016\n\nA weighted planar tree is called a canonical weighted planar\ntangle tree (CWPTT) if it has a single free bond with a label from\nV_4 and satisfies the following conditions:\n\nWeight Condition (W) At each vertex of \\Gamma, at most one weight is\nnon-zero.\n\nStick Conditions\n\n(S.0) On any stick the weights of the vertices are non-zero except for end vertices that have a bond free in\n\\Gamma and for the case \\Gamma is \n\nFigure 41a or \n\nFigure 41b.\n\n\n\n(a)The zero tangle.\n\n\n\n(b)The infinity tangle.\n\n2.(S.A)  The non-zero weights along any stick are of alternating sign.\n3. (S.1) No end vertex of a stick has weight \\pm 1 unless it has a bond free in \\Gamma.\n\nOne of:\n\nPositivity Condition (P) Except for those with a free bond, there are no sticks in \\Gamma of the forms\n\n\nFigure 42a or \n\nFigure 42b.\n\n\n\n(a)The -2 integral tangle.\n\n\n\n(b)A fully open stick with -2 crossings.\n\nNegativity Condition (N) Except for those with a free bond, there are no sticks in \\Gamma of the forms\n\n\nFigure 43a or \n\nFigure 43b.\n\n\n\n(a)The 2 integral tangle.\n\n\n\n(b)A fully open stick with 2 crossings.\n\nNote\n\nThe set of CWPTT for an arborescent tangle can be large.\n\nNote\n\nThe positivity and negativity conditions are a consequence of the behavior of\ntwo crossing tangles seen in Figure~\\ref{minimal-fig-nonmin}. We\nwill adopt the\n\\LP+\\RP as our preferred form.\n\nBonahon and Siebenmann show in \n\nCorollary 1 that these conditions are sufficient to realize\nevery arborescent tangle. In fact, every weighted planar tangle tree can be turned into a CWPTT by a\nseries of moves in an extended calculus on weighted planar trees\n\n\nBonahon & Siebenmann, 2016. We call this process canonization of a weighted planar\ntangle tree.\n\nExistance of CWPTT, Bonahon and Siebenmann, Corollary 12.20 \n\nBonahon & Siebenmann, 2016\n\nEvery arborescent tangle is obtained by plumbing operations from\narborescent tangles associated with positively (or negatively)\ncanonical weighted planar trees (with labels in V_4 at free bonds).\n\nWe note some consequences of the positivity and negativity condition. First, a positive CWPTT\n(\\LP +\\RP-CWPTT) can be transformed by a sequence of moves in the extended calculus of weighted\nplanar trees into a negative CWPTT (\\LP -\\RP-CWPTT). Similarly, a negative CWPTT can be\ntransformed into a positive CWPTT. Second, we note that a CWPTT, with no modification, can be both\npositive and negative. We will refer to these trees as neutral trees.\n\nBonahon and Siebenmann give a classification of arborescent tangles via moves on CWPTT.\n\nClassification Theorem for Canonical Weighted Planar Tangle Trees, Bonahon and Siebenmann, Theorem 12.21 \n\nBonahon & Siebenmann, 2016\n\nConsider two positive (or negative) CWPTT\n\\Gamma^{\\,} and \\Gamma^\\prime, with free bonds labeled by\nelements of V_4. Plumbing according to \\Gamma and \\Gamma^\\prime\ngives isomorphic arborescent tangles if and only if \\Gamma and\n\\Gamma^\\prime can be deduced from each other by a sequence of moves\n(F_1), (F_2), (F_3^\\prime), and the modified ring moves \\LP\\pm R\\RP.\n\nFurther, Bonahon and Siebenmann describe an algorithm for producing these sequences of moves. This\nalgorithm will be useful to us in \n\nSection 6.2.4.2.\n\nBonahon and Siebenmann, Theorem 12.19 \n\nBonahon & Siebenmann, 2016\n\nThere exists an effective algorithm which, for any weighted planar tree \\Gamma\nwith free bonds labeled by elements of V_4, alters \\Gamma by a sequence of\nmoves of the calculus of arborescent tangles to produce its collection of\npositively (or negatively) canonical weighted planar trees.","type":"content","url":"/tabulation#sec-cwptt-def","position":77},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Canonical Vertex","lvl4":"Canonical Weighted Planar Tangle Trees (CWPTT)","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl5","url":"/tabulation#canonical-vertex","position":78},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Canonical Vertex","lvl4":"Canonical Weighted Planar Tangle Trees (CWPTT)","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":"The conditions for a weighted planar tree to be a CWPTT are phrased for the global context of a\nweighted planar tangle tree. We now recontextualize those conditions for a local view, a single\nvertex of the tree.\n\nA vertex v_i of a weighted planar tangle tree \\Gamma with a single free\nbond labeled from V_4 is said to be \\LP+\\RP-canonical if v_i has at\nmost one non-zero weight w_i, and i is zero (the root) with no conditions or\ni is not zero with the following conditions satisfied:\n\nIf the valence of v_i is 1 and all of:\n\nw_i\\neq 0 unless i=1 and w_0=0 (the weight of the root)\n\nw_i\\neq \\pm 1\n\nIf the valence of v_{i-1} (the parent) is 2 then\n\\text{sign}\\LP w_i\\RP\\neq\\text{sign}\\LP w_{i-1}\\RP unless i=1 and\nw_0=0\n\nIf the valence of v_{i-1} (the parent) is greater than 2 then\nw_i\\neq -2\n\nIf the valence of v_i is 2 and all of:\n\nw_i\\neq 0\n\nIf valence of the parent or valence of the child is greater than 2 (is\nessential) then w_i\\neq \\pm1\n\nIf valence of the parent and valence of the child is greater than 2\n(both are essential) then w_i\\neq \\m2\n\nIf valence of the parent is 2 then\n\\text{sign}\\LP w_i\\RP\\neq\\text{sign}\\LP w_{i-1}\\RP (the parent)\n\nIf valence of the child is 2 then\n\\text{sign}\\LP w_i\\RP\\neq\\text{sign}\\LP w_{i+1}\\RP (the child)\n\nFrom this definition, we now show that these conditions are identical to those in the global context\nof \n\nDefinition 24.\n\n\\Gamma is a \\LP+\\RP-CWPTT if and only if all the vertices of \\Gamma are\n\\LP+\\RP-canonical.\n\nChecking each canonicity condition locally shows both directions.\n\nThe definition and proof for \\LP -\\RP-canonical vertices are identical. Similarly to the canonical\ntree case, we define a third positivity class for a vertex, the neutral vertex, a vertex that is\nboth \\LP\n-\\RP-canonical and \\LP+\\RP-canonical.\n\n prettier-ignore-start ","type":"content","url":"/tabulation#canonical-vertex","position":79},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Minimalization of CWPTT","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl4","url":"/tabulation#sec-minimalization","position":80},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Minimalization of CWPTT","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":" prettier-ignore-end ","type":"content","url":"/tabulation#sec-minimalization","position":81},{"hierarchy":{"lvl1":"Tabulation","lvl5":"CWPTT are Not Minimal","lvl4":"Minimalization of CWPTT","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl5","url":"/tabulation#cwptt-are-not-minimal","position":82},{"hierarchy":{"lvl1":"Tabulation","lvl5":"CWPTT are Not Minimal","lvl4":"Minimalization of CWPTT","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":"A common measure for the complexity of knots and their relatives is the minimal crossing number.\nThat being the least number of crossings needed to realize the object in a diagram, we call that\ndiagram the minimal diagram. It is natural to ask if our CWPTT are minimal representatives among\neither all representations or arborescent representations. A quick analysis of the process of\ncanonization demonstrates that CWPTT are unfortunately far from minimal even among arborescent\nrepresentatives. An example of canonizing a tangle, making that tangle non-minimal, is seen in\n\n\nFigure 44a.\n\n\n\n(a)A minimal presentation of a arborescent tangle in both its orthogonal projection\nas well as its weighted planar tree.\n\n\n\n(b)A non-minimal presentation of the same arborescent tangle as\n\n\nFigure 44a in both its orthogonal projection as well as its CWPTT.\n\nFigure 44:Minimal and non-minimal trees.","type":"content","url":"/tabulation#cwptt-are-not-minimal","position":83},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Canonization Can Increase Complexity","lvl4":"Minimalization of CWPTT","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl5","url":"/tabulation#canonization-can-increase-complexity","position":84},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Canonization Can Increase Complexity","lvl4":"Minimalization of CWPTT","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":"As we have seen, a CWPTT often does not realize a minimal crossing representative for an arborescent\ntangle. Since minimal crossing number is such a common measure for complexity, we should understand\nhow canonization impacts the crossing number complexity of a CWPTT. We will accomplish this by\nidentifying a (non-unique) minimal arborescent representative for each tangle. That is, a weighted\nplanar tangle tree with minimal TCN among all weighted planar tangle trees in its equivalence class.\nTo begin we expand our understanding of the moves in the calculus of arborescent tangles to those\nthat alter weights arithmetically. These moves are related to the arithmetic operations on continued\nfractions \n\nBonahon & Siebenmann, 2016.\n\nBonahon and Siebenmann, Section 12.3 \n\nBonahon & Siebenmann, 2016\n\nWhen carrying out the following arithmetic moves the relative positions of weights are\ncritical to the invariance of the underlying knot pair.\n\n(0.1) The 0.1 move replaces the left side with the right side of \n\nFigure 45.\n\n\n\nFigure 45:Move 0.1 on a weighted planar tree.\n\n(0.2) The 0.2 move replaces the left side with the right side of \n\nFigure 46. Additionally, the cyclic order of all descendants in the purple subtree is reversed and \\zeta (Z-axis rotation \n\nFigure 19d). The vertices a and b need not be valence two, either or both may have a valence greater than two.\n\n\n\nFigure 46:Move 0.2 on a weighted planar tree.\n\n(1.1) The 1.1 move replaces the left side with the right side of \n\nFigure 47.\n\n\n\nFigure 47:Move 1.1 on a weighted planar tree.\n\n(1.2) The 1.2 move replaces the left side with the right side of \n\nFigure 48. The vertices a and b need not be valence two, either or both may have a valence greater than two.\n\n\n\nFigure 48:Move 1.2 on a weighted planar tree.\n\n(2.1) Replace the left side with the right side of \n\nFigure 49\n\n\n\nFigure 49:Move 2.1 on a weighted planar tree.\n\n(2.2) Replace the left side with the right side of \n\nFigure 50. The vertices a and b need not be valence two, either or both may have a valence greater than two.\n\n\n\nFigure 50:Move 2.2 on a weighted planar tree.\n\nNote\n\nThe 2.1 and 2.2 moves are what allow us to pass between the \\LP+\\RP and\n\\LP-\\RP canonical classes of trees.\n\nFrom here we will show that canonization of minimal trees increases TCN complexity in a controlled\nmanner.\n\nA minimal tree canonizes to \\LP+\\RP-CWPTT, with only the moves (1.2), (2.1),\nand (2.2) increasing TCN.\n\nLet \\Gamma be a minimal TCN arborescent representative of its equivalence\nclass. Starting with the weight condition\n(W) maximally apply F_3 consolidating the weights of each vertex.\nF_3 may need to be reapplied after application of arithmetic moves\nand does not impact TCN.\n\nNext we handle the stick condition starting with condition S.0 concerning\nsticks having non-zero weights. Maximally apply\nto \\Gamma moves 0.1 and 0.2; this removes zero weights of\nsticks. In the general canonization process S.A, the alternating\nstick condition, is handled by application\nof move 1.2. However, on a pair of vertices violating condition\nS.A, move 1.2\ndecreases the TCN. This means by minimality of \\Gamma, condition\nS.A must already be\nsatisfied. Finally to obtain condition S.1, we apply moves 1.1 and\n1.2, where move 1.2 may increase crossing number by 1.\n\nThe last condition to enforce is P, the positivity condition, which is\ndone by modifying \\Gamma by application of moves 2.1\nand 2.2. Similarly to our S.1 case, \\Gamma is minimal, 2.1,\nand 2.2 cannot decrease TCN. However, 2.1 and 2.2 may increase TCN\nby 1 and 2 respectively.\n\nWe note that \n\nTheorem 6 indicates that any opportunities to decrease TCN in a CWPTT are\nfound on the end vertices of sticks adjacent to an essential vertex. Particularly, at least one\nweight used in the execution of 1.2, 2.1, and 2.2 must be carried by an essential vertex. Reversing\nthe sequence of moves in \n\nTheorem 6 tells us that a minimal tree can be constructed from a\nCWPTT by application of TCN decreasing moves 1.2, 2.1, and 2.2. It is important to note that this\ndoes not guarantee that every set of applications of the 1.2, 2.1, and 2.2 moves to a CWPTT\nminimizes the TCN, only the existence of a path to a minimal tree.","type":"content","url":"/tabulation#canonization-can-increase-complexity","position":85},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Bounding complexity","lvl4":"Minimalization of CWPTT","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"type":"lvl5","url":"/tabulation#bounding-complexity","position":86},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Bounding complexity","lvl4":"Minimalization of CWPTT","lvl3":"Weighted Planar Trees","lvl2":"Arborescent Tangles"},"content":"We now introduce a bound on complexity between a CWPTT and a minimal representation of that tree. We\nbuild the bound by identifying the maximum number of subtrees of a CWPTT which admit a 1.2, 2.1, or\n2.2 move. We begin by identifying the smallest TCN of a subtree that admits each move. These minimal\nsubtrees follow directly from Definition~\\ref{minimal-def-arithmetic} and our essential vertex\nrequirement. The smallest, by TCN, canonical subtree admitting move 1.2 is 7, as in\n\n\nFigure 51a. For move 2.1 the smallest TCN for a canonical subtree is 5, as in\n\n\nFigure 51b, and for 2.2 the smallest TCN is 10, as in\n\n\nFigure 51c. Combining these smallest TCN subtrees with the how each move decreases\nTCN gives the bound in \n\n(11), where \\Gamma_m is a minimal representative for the\ntangle class of \\Gamma.\\begin{aligned}\n\\text{TCN}\\LP\\Gamma\\RP-\\text{TCN}\\LP\\Gamma_m\\RP&\\leq\n1\\cdot\\left\\lfloor\\frac{\\text{TCN}\\LP\\Gamma\\RP}{7}\\right\\rfloor+1\\cdot\\left\\lfloor\\frac{\\text{TCN}\\LP\\Gamma\\RP}{5}\\right\\rfloor+2\\cdot\\left\\lfloor\\frac{\\text{TCN}\\LP\\Gamma\\RP}{10}\\right\\rfloor\\\\\n&\\leq\n\\frac{\\text{TCN}\\LP\\Gamma\\RP}{7}+\\frac{\\text{TCN}\\LP\\Gamma\\RP}{5}+2\\cdot\\frac{\\text{TCN}\\LP\\Gamma\\RP}{10}\\\\\n&=\\frac{\\text{TCN}\\LP\\Gamma\\RP\\cdot 19}{35}\\\\\n\\end{aligned}\n\n\n\n(a)Admits move 1.2\n\n\n\n(b)Admits move 2.1\n\n\n\n(c)Admits move 2.2\n\nExamples of canonical subtrees of a \\LP+\\RP-CWPTT which admit the given moves.\nNote: These are subtrees admiting the moves, but not the only subtrees admiting\nthe moves.\n\n prettier-ignore-start ","type":"content","url":"/tabulation#bounding-complexity","position":87},{"hierarchy":{"lvl1":"Tabulation","lvl3":"Right Leaning Identity CWPTT","lvl2":"Arborescent Tangles"},"type":"lvl3","url":"/tabulation#subsec-rlitt","position":88},{"hierarchy":{"lvl1":"Tabulation","lvl3":"Right Leaning Identity CWPTT","lvl2":"Arborescent Tangles"},"content":" prettier-ignore-end \n\nThe CWPTT are sufficient for distinguishing any two arborescent tangles via moves on their trees.\nUnfortunately, the equivalence class of CWPTT is still too large for computational enumeration to be\nfeasible. The time required for pairwise comparisons grows badly exponentially. Luckily, from the\nclass of CWPTT for an arborescent tangle, we can select a unique preferred form that allows for\nefficient direct enumeration by computer. To achieve this we will define two additional conditions\nfor CWPTT, first the right leaning condition, and second, the identity condition. We call these\npreferred CWPTT Right Leaning Identity Canonical Weighted Planar Tangle Trees (RLITT).\n\n","type":"content","url":"/tabulation#subsec-rlitt","position":89},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Existence of Right Leaning CWPTT","lvl3":"Right Leaning Identity CWPTT","lvl2":"Arborescent Tangles"},"type":"lvl4","url":"/tabulation#existence-of-right-leaning-cwptt","position":90},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Existence of Right Leaning CWPTT","lvl3":"Right Leaning Identity CWPTT","lvl2":"Arborescent Tangles"},"content":"We start our construction of RLITT by defining what conditions make a CWPTT a right leaning CWPTT.\n\nA CWPTT is called right leaning if all weights are in the highest indexed\nregion (as in \n\nIndexing the total order of a tree) of each vertex. Additionally, any ring subtrees\nthat are children of a vertex are the highest indexed children of that vertex.\n\nOur next step is to show that every arborescent tangle has a right leaning representative.\n\nEvery arborescent tangle has a right leaning CWPTT representative.\n\nLet \\Gamma be a CWPTT representative for a tangle T. If every weight\nw_i of \\Gamma is in the highest indexed region of \\Gamma_{w_i}, we\nare done. Otherwise, we will follow a similar algorithm to that outlined by\nBonahon and Siebenmann \n\nBonahon & Siebenmann, 2016 for distinguishing\nCWPTT. Let w_i be the weight for the lowest indexed vertex v_i not in its\nhighest indexed region of \\Gamma_{v_i}. With move F_3^\\prime shift w_i so\nthat it lies in the highest indexed region. Further, choose to shift w_i\nanti-clockwise, this ensures that v_j with j<i are unchanged when w_i is\neven. We repeat this process for any v_k with i<k where the weight w_k is not\nin the highest indexed region. Since \\Gamma has finite vertices, the\nalgorithm terminates with a \\Gamma transformed into a right leaning tree\ncompleting the proof.","type":"content","url":"/tabulation#existence-of-right-leaning-cwptt","position":91},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Existence of Identity CWPTT","lvl3":"Right Leaning Identity CWPTT","lvl2":"Arborescent Tangles"},"type":"lvl4","url":"/tabulation#existence-of-identity-cwptt","position":92},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Existence of Identity CWPTT","lvl3":"Right Leaning Identity CWPTT","lvl2":"Arborescent Tangles"},"content":"Our second step in the construction of RLITT is to define what conditions make a CWPTT an identity\nCWPTT.\n\nA CWPTT is called an identity tree if its free bond is marked by\n\\iota\\in V_4.\n\nAgain, we must show that every arborescent tangle has an identity representative.\n\nEvery arborescent tangle has an identity CWPTT representative.\n\nLet \\Gamma be a CWPTT representative for a tangle T. If the label\n\\alpha for the free bond of \\Gamma is \\iota we are done. Otherwise,\nwe fall into one of three cases:\n\n\\alpha=\\zeta: In the case \\alpha is \\zeta we apply move F_1. This\nmodifies \\alpha by \\zeta yielding \\alpha\\zeta=\\zeta\\zeta=\\iota.\n\n\\alpha=\\eta: In the case \\alpha is \\eta we apply move F_{2e}. This\nmodifies \\alpha by \\eta yielding \\alpha\\eta=\\eta\\eta=\\iota.\n\n\\alpha=\\xi: In the case \\alpha is \\xi we apply move F_{2o}. This\nmodifies \\alpha by \\xi yielding \\alpha\\xi=\\xi\\xi=\\iota.\n\nThis transforms \\Gamma into an identity tree completing the proof.","type":"content","url":"/tabulation#existence-of-identity-cwptt","position":93},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Existence of Right Leaning Identity CWPTT (RLITT)","lvl3":"Right Leaning Identity CWPTT","lvl2":"Arborescent Tangles"},"type":"lvl4","url":"/tabulation#existence-of-right-leaning-identity-cwptt-rlitt","position":94},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Existence of Right Leaning Identity CWPTT (RLITT)","lvl3":"Right Leaning Identity CWPTT","lvl2":"Arborescent Tangles"},"content":"What we have shown is that every arborescent tangle has at least one right leaning CWPTT and at\nleast one identity CWPTT representative. Combining these two ideas, we will show that every\narborescent tangle has at least one CWPTT that is right leaning and identity, we call such a CWPTT\nan RLITT.\n\nA CWPTT is called a right leaning identity tangle tree (RLITT) if it’s a\nright leaning and identity tree.\n\nEvery CWPTT has a right leaning identity representative.\n\nLet \\Gamma be an identity CWPTT representative for a tangle T.\nApplying the algorithm described in the proof of\n\n\nTheorem 7 transforms \\Gamma into a right leaning\ntree. Our requirement that F_3^\\prime be anti-clockwise ensures that the\nresulting tree retains label \\iota. This shows that \\Gamma can be\nrepresented as a right leaning identity CWPTT.\n\n","type":"content","url":"/tabulation#existence-of-right-leaning-identity-cwptt-rlitt","position":95},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Uniqueness of Right Leaning Identity CWPTT","lvl3":"Right Leaning Identity CWPTT","lvl2":"Arborescent Tangles"},"type":"lvl4","url":"/tabulation#uniqueness-of-right-leaning-identity-cwptt","position":96},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Uniqueness of Right Leaning Identity CWPTT","lvl3":"Right Leaning Identity CWPTT","lvl2":"Arborescent Tangles"},"content":"Our final step at identifying a preferred representative CWPTT of an arborescent tangle is to show\nthat a \\LP +\\RP-RLITT is unique in the set of CWPTT representing an arborescent tangle. We will\nutilize the key proposition from Bonahon and Siebenmann \n\nBonahon & Siebenmann, 2016 a\nconsequence of \n\nTheorem 3 and \n\nTheorem 4.\n\nBonahon and Siebenmann, Proposition 12.2 \n\nBonahon & Siebenmann, 2016\n\nLet \\Gamma and \\Gamma^\\prime be \\LP +\\RP-CWPTT tangle trees\nwith isomorphic\nunderlying abstract trees. Further, let \\varphi be a sequence of moves of the\ncalculus of arborescent tangles (F_1, F_2, F_3^\\prime, and the\nmodified ring moves \\LP\\pm R\\RP). Assume that there is an i > 0 such that\n\\varphi respects the cyclic orders of weight and bonds at each vertex v_j\nwith j < i, and that the labels of the free bond \\alpha in\n\\Gamma and of \\varphi\\LP \\alpha\\RP in \\Gamma^\\prime are identical. Assume\nmoreover, that one of:\n\n\\varphi reverses the cyclic order of bonds at v_i\n\n\\varphi does not respect the label in V_4 of some free bond of a\nvertex v_j with 1 \\leq j < i.\n\nThen \\varphi is not a sequence of moves of the calculus of arborescent tangles\ntaking \\Gamma^\\prime to \\Gamma.\n\nThe \\LP +\\RP-RLITT representative is unique in the class of CWPTT.\n\nLet \\Gamma and \\Gamma^\\prime be two \\LP +\\RP-RLITT representatives for an arborescent\ntangle T. Assume for the sake of contradiction that\n\\Gamma\\neq \\Gamma^\\prime, meaning T has two distinct \\LP +\\RP-RLITT. The\nclassification result in \n\nTheorem 3 and algorithm given\nby \n\nTheorem 4 we produce a sequence of moves in the\ncalculus of arborescent tangles that takes \\Gamma^\\prime to \\Gamma. Let\n\\varphi be such a sequence. By construction the labels in V_4 of \\Gamma\nand \\Gamma^\\prime agree. Now, since \\Gamma\\neq \\Gamma^\\prime there must be a\nfirst, in the total order, vertex v_i where \\Gamma and \\Gamma^\\prime\ndisagree. As \\LP +\\RP-RLITT, the location of weights for v_i in \\Gamma and\n\\Gamma^\\prime must appear in the same region. This requires that the\ndisagreement at v_i must be in cyclic order of its children. We find ourselves\nin the first case of \n\nProposition 1, making \\varphi not a\nsequence of moves of the calculus of arborescent tangles taking \\Gamma^\\prime\nto \\Gamma.\n\n prettier-ignore-start ","type":"content","url":"/tabulation#uniqueness-of-right-leaning-identity-cwptt","position":97},{"hierarchy":{"lvl1":"Tabulation","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"type":"lvl3","url":"/tabulation#subsec-computation","position":98},{"hierarchy":{"lvl1":"Tabulation","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"content":" prettier-ignore-end \n\n prettier-ignore-start ","type":"content","url":"/tabulation#subsec-computation","position":99},{"hierarchy":{"lvl1":"Tabulation","lvl4":"An Encoding Strategy for Arborescent Knots and Tangles","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"type":"lvl4","url":"/tabulation#sec-arborescent-linear","position":100},{"hierarchy":{"lvl1":"Tabulation","lvl4":"An Encoding Strategy for Arborescent Knots and Tangles","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"content":" prettier-ignore-end \n\nThe various flavors of weighted planar trees we have seen thus far are a useful tool for\nmanipulation of arborescent tangles by humans or machines. Unfortunately, the tree structure is\nquite difficult to store directly in a computer database. We will rectify this by introducing a\nlinearization strategy for weighted planar trees. This linearization strategy is designed to encode\nnot only CWPTT but arbitrary weighted planar tangle trees. If a weighted planar tangle tree has more\nthan one free bond we list the label as a subtree. We will omit this from our algorithm description\nas we are primarily concerned with RLITT.\n\nNote\n\nThe strategy outlined here is designed for linearizing tangles. A small\nmodification must be made for use with knots. That being, in the knot case,\nignore the 0^{\\text{th}} weight position for the root.\n\nWe will descend the tree following the indexing of the total order (\n\nIndexing the total order of a tree). As we descend\nthe tree, we annotate the linearization with two sets of delimiters. Each delimiter communicates\nextra information about the type of subtree it is delimiting, the two sets of delimiters are as\nfollows:\n\n\\LB\\ \\RB: Corresponds to a half-open proper stick and is interpreted as a twist vector for a\nrational tangle \n\nKauffman & Lambropoulou (2002).\n\n\\LP\\ \\RP: Corresponds to a vertex not on a half-open stick.\n\nWe will now walk through an example of the linearization algorithm. Let \\Gamma be a weighted\nplanar tangle tree seen in \n\nFigure 52. As we walk the tree, the vertex currently being\nlinearized will be called the object vertex.","type":"content","url":"/tabulation#sec-arborescent-linear","position":101},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Tangle Linearization Example","lvl4":"An Encoding Strategy for Arborescent Knots and Tangles","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"type":"lvl5","url":"/tabulation#tangle-linearization-example","position":102},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Tangle Linearization Example","lvl4":"An Encoding Strategy for Arborescent Knots and Tangles","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"content":"We begin by adding the V_4 label for our tangle to the linearization. We then start the following\nalgorithm with the root as the object vertex.\n\nFor the object vertex, we add a ‘\\LP\\ \\right.’ delimiter to our linearization. Adding to our\nlinearization the weights and children of the object vertex in an anti-clockwise order. When a child\nbond is encountered, we descend to that child. When we descend, we have two cases to consider, the\nchild is a half-open proper stick or otherwise.","type":"content","url":"/tabulation#tangle-linearization-example","position":103},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Case 1: The Child Is The Root Of A Half-Open And Proper Stick","lvl4":"An Encoding Strategy for Arborescent Knots and Tangles","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"type":"lvl5","url":"/tabulation#case-1-the-child-is-the-root-of-a-half-open-and-proper-stick","position":104},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Case 1: The Child Is The Root Of A Half-Open And Proper Stick","lvl4":"An Encoding Strategy for Arborescent Knots and Tangles","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"content":"When the child is the root of a is proper and half-open (contains a leaf vertex), we append that\nstick as the twist vector (\n\nDefinition 2) for the corresponding rational tangle. Let the\nstick consist of the vertices, v_i\\cdots v_{i+k}, and weights, w_i\\cdots w_{i+k}. We delimit the\nstick with \\LB\\ \\RB, with each weight separated by a space, and the leaf weight as the left most\nentry of the twist vector. Further, every other entry is multiplied by -1, forcing the sign of all\nentries to match, as in \n\n(12).\\LB w_{i+k}\\ \\m w_{i+k-1}\\cdots\\ \\m w_{i-1}\\ w_{i}\\RB","type":"content","url":"/tabulation#case-1-the-child-is-the-root-of-a-half-open-and-proper-stick","position":105},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Case 2: The Child Is Essential, On A Open Stick, Or On A Non-Proper Stick","lvl4":"An Encoding Strategy for Arborescent Knots and Tangles","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"type":"lvl5","url":"/tabulation#case-2-the-child-is-essential-on-a-open-stick-or-on-a-non-proper-stick","position":106},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Case 2: The Child Is Essential, On A Open Stick, Or On A Non-Proper Stick","lvl4":"An Encoding Strategy for Arborescent Knots and Tangles","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"content":"In this case, we restart the algorithm from the beginning with the current vertex as the object\nvertex.\n\nWhen we have exhausted the children for the object vertex, we close our linearization for that\nvertex with the delimiter ‘\\LN\\ \\RP’. We then return to the parent linearization, repeating until\nall vertices have been exhausted. An example of a tree encoded with this strategy can be seen in\n\n\nFigure 52.\n\n\n\nFigure 52:Encoded tree subtrees are indicated by color.\n\n prettier-ignore-start ","type":"content","url":"/tabulation#case-2-the-child-is-essential-on-a-open-stick-or-on-a-non-proper-stick","position":107},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Generation of Right Leaning Identity Weighted Planar Tangle Trees","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"type":"lvl4","url":"/tabulation#sec-rlitt-generation","position":108},{"hierarchy":{"lvl1":"Tabulation","lvl4":"Generation of Right Leaning Identity Weighted Planar Tangle Trees","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"content":" prettier-ignore-end ","type":"content","url":"/tabulation#sec-rlitt-generation","position":109},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Generation of Rooted Plane Tree","lvl4":"Generation of Right Leaning Identity Weighted Planar Tangle Trees","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"type":"lvl5","url":"/tabulation#generation-of-rooted-plane-tree","position":110},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Generation of Rooted Plane Tree","lvl4":"Generation of Right Leaning Identity Weighted Planar Tangle Trees","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"content":"Just as rooted plane trees serve as the scaffolding we built WPTT on, a rooted plane tree algorithm\nwill serve as the backbone for our RLITT generation algorithm. We will now give a brief description\nof the generation algorithm for rooted plane trees given by Nakano\n\n\nNakano, 2002. We begin by defining the rightmost path of a rooted plane\ntree \\Gamma.\n\nNakano, Section 2 \n\nNakano, 2002\n\nLet v_0 be the root and v_i be the highest indexed leaf (vertex of valence\n\\leq 1) of a rooted plane tree \\Gamma. The unique path\n\\LP v_0,\\,\\cdots,\\,v_i \\RP, in the standard graph theoretic sense, is called\nthe rightmost path of \\Gamma.\n\nNext, we define a grafting operation on rooted plane trees \\Gamma and \\Gamma^\\prime.\n\nLet \\mathcal{T}^{p}_{n} be the set of rooted plane trees on n vertices,\n\\Gamma_r\\in \\mathcal{T}^{p}_{n} , and \\Gamma_s\\in \\mathcal{T}^{p}_{m}.\nDefine the grafting operation as follows.\\begin{aligned}\n\\star_i:\\mathcal{T}^{rp}_{n}\\times\\mathcal{T}^{rp}_{m}&\\to\\mathcal{T}^{rp}_{n+m}\\\\\n\\Gamma_r\\times\\Gamma_s&\\mapsto\\Gamma_r\\star_i\\Gamma_s\n\\end{aligned}\n\nAt the vertex v_i of \\Gamma_r, introduce an edge to the root of \\Gamma_s.\nNow, adjust the indexing of a vertex s_k of \\Gamma_s as v_{n+k}, placing\n\\Gamma_s as the rightmost child of v_i. This results in a rooted plane tree\n\\Gamma\\in \\mathcal{T}^{rp}_{n+m}.\n\nWhen grafting at the root v_0 we omit the index label in the grafting\noperation, that is, \\star_0 is written simply as \\star. We call \\Gamma_r the\nrootstock and \\Gamma_s the scion.\n\n\n\nGrafting a scion \\Gamma_s to a rootstock \\Gamma_r with \\Gamma_r\\star_3\\Gamma_s\n\nNow we are prepared to give the algorithm to generate all rooted plane trees of a given size that\nare created from \\Gamma by a sequence of \\star_\\ast operations on the rightmost path of\n\\Gamma.\n\nFind all rooted plane trees of a given size created from \\Gamma \n\nNakano, 2002\n\nInput\n\nA tree \\Gamma\\in \\mathcal{T}^{rp}_{i}, i<n\n\nA target size n\\in T\n\nOutput\n\nAll collections of trees \\Gamma\\in \\mathcal{T}^{rp}_{n} created from \\Gamma\n\nRoutine\n\nSet P to the rightmost path of \\Gamma\n\nSet \\Gamma_1 as the single vertex rooted plane tree\n\nIf the number of vertices of \\Gamma is n exit the algorithm\n\nFor each vertex v_i in P\n\nGraft \\Gamma_1 onto \\Gamma as \\Gamma\\star_i \\Gamma_1=\\Gamma^\\prime\n\nStart a new instance of \n\nAlgorithm 6 with\n\\Gamma=\\Gamma^\\prime and size=size\n\nThis algorithm can be extended to an algorithm that finds all rooted plane trees up to a given size\nas follows.\n\nEfficient generation of rooted plane trees \n\nNakano, 2002\n\nInput\n\nA target number of vertices of a tree n\\in \\Z\n\nOutput\n\nAll trees \\Gamma\\in \\mathcal{T}^{rp}_{n}\n\nRoutine\n\nSet \\Gamma_1 as the single vertex rooted plane tree\n\nExecute \n\nAlgorithm 6 with \\Gamma=\\Gamma_1 and n=n","type":"content","url":"/tabulation#generation-of-rooted-plane-tree","position":111},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Modification for RLITT","lvl4":"Generation of Right Leaning Identity Weighted Planar Tangle Trees","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"type":"lvl5","url":"/tabulation#modification-for-rlitt","position":112},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Modification for RLITT","lvl4":"Generation of Right Leaning Identity Weighted Planar Tangle Trees","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"content":"The algorithm described above serves as the inspiration for the algorithm we will build now for the\nenumeration of the arborescent tangles. Building this algorithm begins with modifying the grafting\n\\star_i operation to operate on weighted planar tangle trees as follows.\n\nThe grafting operation \\star_i for weighted planar tangle trees, we require\nthat the free bond of the scion be grafted to v_i. We also specify that the\nscion be grafted so that the rightmost weight of v_i remains to the right of\nthe scion after grafting; this can be seen in\n\n\nFigure 54.\n\n\n\n(a)A rootstock \\Gamma_r=\\iota\\LP \\LP2\\LP2\\LB3\\RB2\\LB -3\\RB3\\RP \\LB3\\RB4\\RP 4\\RP in grey and scion \\Gamma_s=\\iota\\LB 10\\ 9 \\RB in orange. Each vertex is\nlabeled with its index in the order on \\Gamma.\n\n\n\n(b)Grafting at v_2 yields \\Gamma_r\\star_2\\Gamma_s=\\iota\\LP \\LP2\\LP2\\LB3\\RB2\\LB -3\\RB\\LB 10\\ 9 \\RB 3\\RP \\LB3\\RB4\\RP 4\\RP\n\nFigure 54:Grafting trees.\n\nJust as we have adjusted the grafting operator, we must adjust the Nakano algorithm so it is aware\nof the extra data in an RLITT. The initial reaction to this problem may be to simply annotate the\nscion of the grafting operation with the weights necessary to reach a target TCN. Unfortunately,\nthis method quickly runs into issues generating even just the Montesinos tangles, a smaller class of\ntangle described by \n\nBonahon & Siebenmann, 2016 We must make a slightly more radical change\nto the Nakano algorithm, that being, grafting an entire RLITT to only the root v_0 of the\nrootstock. We will now show that a list of integral tangles (single vertex RLITT)\n\n\nSection 5.3.3 combined with grafting at the root generates all \\LP+\\RP-RLITT. To start,\nwe will prove that each \\LP+\\RP-RLITT is integral or the result of grafting weighted planar tangle\ntrees at the root.\n\nEvery \\Gamma \\LP+\\RP-RLITT of TCN n is one of two forms:\n\n\\Gamma is a single vertex with weight \\pm n.\n\n\\Gamma is the result of grafting at the root of some rootstock \\Gamma_r\nand \\LP+\\RP-RLITT scion \\Gamma_s where:\n\nIn \\Gamma_r, v_0 is valence two, and v_1 is canonical\nexcept for violating the stick condition by\n\\text{Sign}\\LP v_0\\RP=\\text{Sign}\\LP v_1\\RP. Each vertex in\n\\LS v_i\\RS_{i=2}^n of \\Gamma_r is \\LP +\\RP-canonical.\n\n\\Gamma_r is \\LP+\\RP-RLITT\n\nLet \\Gamma be a \\LP +\\RP-RLITT, we have three cases based on the valence of\nv_0\\in \\Gamma.\n\nThe valence of v_0 is:\n\nOne: \\Gamma is integral (\n\nIntegral Tangles), we fall into\nthe first condition.\n\nTwo: \\Gamma is a stick at the root, we let \\Gamma_r=\\iota\\LB w_0\\RB\nand \\Gamma_s=\\iota\\LP\\alpha w_1\\RP, where \\alpha is the remaining\nvertices, weights, and bonds of \\Gamma. \\Gamma_r is integral, and as such\nis \\LP+\\RP-RLITT. Now to show that \\Gamma_s is \\LP+\\RP-RLITT. Since\n\\Gamma is \\LP+\\RP-RLITT, each v_i in \\Gamma is canonical. Each vertex\nin \\Gamma_s is also in \\Gamma, so \\Gamma_s has only canonical vertices\nand by \n\nTheorem 5 is \\LP+\\RP-canonical. Finally, since locations of\nweights are unchanged and grafting requires the scion to have identity label\n\\Gamma_s is \\LP+\\RP-RLITT.\n\nThree: The root of \\Gamma has two children, we let \\Gamma_s be the tree\nwith the right child of v_0 as a root and\n\\Gamma_r=\\iota\\LP \\alpha w_0\\RP, where \\alpha is the remaining vertices,\nweights, and bonds of \\Gamma. Showing \\Gamma_s is \\LP+\\RP-RLITT follows\nidentically as it did in the first form.\n\nWe now show \\Gamma_r is \\LP+\\RP-RLITT. First, given that \\Gamma is\n\\LP+\\RP-RLITT, each v_i in \\Gamma is canonical, consequently each\nvertex that is unchanged in \\Gamma_r (\\LS v_i\\RS_{i=2}^n) is canonical.\nThe vertices that differ in \\Gamma_r are v_0 and v_1, v_0 remains\nthe root of \\Gamma_r so is canonical. Showing the canonicity of v_1\ndepends on the the valence of v_1. When the valence is 0 or is greater\nthan 2, \\Gamma_r is \\LP+\\RP-RLITT by the same argument as \\Gamma_s.\nWhen v_1 is valence 1 or 2, \\Gamma_r begins with a stick, and v_1\ncontinues to satisfy the weight, positivity, and the \\pm 1 and 0 portion\nof the stick condition. For the sign condition, when the signs agree, we are\nin form 2.1 of this theorem, and when they disagree, we are in form 2.2.\n\nGreater than Three: The final case is when the valence of v_0 is greater\nthan three. We let \\Gamma_s be the tree with the right child of v_0 as a\nroot and \\Gamma_r=\\iota\\LP \\alpha w_0\\RP, where \\alpha is the remaining\nvertices, weights, and bonds of \\Gamma. Both \\Gamma_r and \\Gamma_s\nfollow the same argument used for \\Gamma_s of the valence 1 case.\n\nAn identical theorem can be phrased for the \\LP-\\RP-RLITT case. With this result, we can start our\nconstruction of a grafting algorithm for arborescent tangles.\n\nFind weighted planar trees by grafting RLITT scions to the root of RLITT rootstocks\n\nInput\n\nA collection of of RLITT scions T_s\n\nA collection of RLITT rootstocks T_r\n\nOutput\n\nA collection of weighted planar trees\n\nRoutine\n\nFor each combination of \\Gamma_r\\in T_r and \\Gamma_s \\in T_s\n\nCompute \\Gamma_r\\star \\Gamma_s\n\nExecuting the algorithm with \\Gamma_r=\\LS \\iota\\LB\n1\\RB\\RS as the rootstock and\n\\Gamma_s=\\LS \\iota\\LB 2\\ 0\\RB\\RS produces the tangle \\iota\\LB 2\\ 0\\ 1\\RB. Unfortunately, this\nresultant tangle violates the stick condition and hence is not canonical. The remainder of this\nsubsection will refine the grafting algorithm to satisfy each of the RLITT conditions.","type":"content","url":"/tabulation#modification-for-rlitt","position":113},{"hierarchy":{"lvl1":"Tabulation","lvl6":"Weight Condition","lvl5":"Modification for RLITT","lvl4":"Generation of Right Leaning Identity Weighted Planar Tangle Trees","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"type":"lvl6","url":"/tabulation#weight-condition","position":114},{"hierarchy":{"lvl1":"Tabulation","lvl6":"Weight Condition","lvl5":"Modification for RLITT","lvl4":"Generation of Right Leaning Identity Weighted Planar Tangle Trees","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"content":"The simplest condition to verify is the weight condition. By construction, grafting the rootstock\nand scion introduces no additional weights at the grafting vertex. Meaning, the weight condition is\nsatisfied with no adjustment to the algorithm.","type":"content","url":"/tabulation#weight-condition","position":115},{"hierarchy":{"lvl1":"Tabulation","lvl6":"Identity Condition","lvl5":"Modification for RLITT","lvl4":"Generation of Right Leaning Identity Weighted Planar Tangle Trees","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"type":"lvl6","url":"/tabulation#identity-condition","position":116},{"hierarchy":{"lvl1":"Tabulation","lvl6":"Identity Condition","lvl5":"Modification for RLITT","lvl4":"Generation of Right Leaning Identity Weighted Planar Tangle Trees","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"content":"The next RLITT condition to address is the identity condition. We note that the \\star_i operation\ndoes not modify the V_4 label of the rootstock. This observation means if the rootstock is\nidentity, the grafted tree will also be identity. prettier-ignore-start ","type":"content","url":"/tabulation#identity-condition","position":117},{"hierarchy":{"lvl1":"Tabulation","lvl6":"Stick Condition","lvl5":"Modification for RLITT","lvl4":"Generation of Right Leaning Identity Weighted Planar Tangle Trees","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"type":"lvl6","url":"/tabulation#rli-gen-sec-stick-con","position":118},{"hierarchy":{"lvl1":"Tabulation","lvl6":"Stick Condition","lvl5":"Modification for RLITT","lvl4":"Generation of Right Leaning Identity Weighted Planar Tangle Trees","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"content":" prettier-ignore-end \n\nTo start with the stick condition we will prove that if grafting produces a non-canonical tree the\nnon-canonical vertex must be adjacent to the root.\n\nFor \\Gamma_r a \\LP+\\RP-RLITT and \\Gamma_s a \\LP+\\RP-RLITT scion,\nthe result of \\Gamma=\\Gamma_r\\star\\Gamma_s is canonical if all\nv_i at distance 1 or less from the root are canonical.\n\nWe need to show that each vertex v_i at a distance greater than one from the\nroot of \\Gamma=\\Gamma_r\\star\\Gamma_s is canonical. The vertex v_i is also a\nvertex of either \\Gamma_r or \\Gamma_s. If the vertex is in \\Gamma_r, then\nv_i has a parent in \\Gamma_r and if the valence of v_i is 2 or more\nv_i also has children in \\Gamma_r. The parent and children in \\Gamma are\nthe same as the parent and children in \\Gamma_r. Since \\Gamma_r is RLITT\nv_i is canonical in \\Gamma_r and since it shares a parent and children in\n\\Gamma it is also canonical in \\Gamma. Similarly, for v_i in the scion,\nshowing canonicity of grafting is dependent only on the canonicity of the\nvertices at a distance up to one from the root.\n\nThe \\LP-\\RP-RLITT case is shown identically, covering the majority of possibilities. However, we\nneed to take special care when grafting a non-negative to a non-positive tree (or the reverse).\nBefore we address that case we define a restricted class of scions that, after grafting, satisfy the\nnonzero portion of the stick condition.\n\nAn \\LP+\\RP-RLITT (respectively \\LP+\\RP-RLITT) \\Gamma with root weight w_0\nis called a good scion when either:\n\nw_0\\neq0\n\nw_0=0 and the valence of v_0 is greater than 2 (essential)\n\nFor \\Gamma_r a non-negative \\LP+\\RP-RLITT, and \\Gamma_s a good\nnon-positive \\LP-\\RP-RLITT scion, the result of\n\\Gamma=\\Gamma_r\\star\\Gamma_s is non-canonical.\n\n\\Gamma_r is a non-neutral \\LP+\\RP-RLITT, so it has a non-root vertex v_{i},\nwhich is a stick of the form \n\nFigure 42a or\n\n\nFigure 42b. Similarly, \\Gamma_s is a non-neutral\n\\LP+\\RP-RLITT, so it has a non-root vertex v_{j}, which is a stick of the\nform \n\nFigure 43a or \n\nFigure 43b.\nSince v_i and v_j are not at the root, they remain sticks of the form\n\n\nFigure 42a, \n\nFigure 42b,\n\n\nFigure 43a, or \n\nFigure 43b\nafter grafting. Making \\Gamma neither \\LP+\\RP-RLITT nor \\LP-\\RP-RLITT, as\nwe desired.\n\nFind weighted planar trees by grafting RLITT good scions to the root of RLITT rootstocks\n\nInput\n\nA collection of RLITT good scions T_s\n\nA collection of RLITT rootstocks T_r\n\nOutput\n\nA collection of weighted planar trees (still not guaranteed to be RLITT)\n\nRoutine\n\nFor each combination of \\Gamma_s\\in T_s and \\Gamma_r \\in T_r\n\nCompute \\Gamma = \\Gamma_r\\star \\Gamma_s\n\nFor each vertex v_i at distance 1 from the root of \\Gamma\n\nContinue to the next iteration of the outer loop if v_i fails to satisfy the stick condition\n\nReport \\Gamma prettier-ignore-start ","type":"content","url":"/tabulation#rli-gen-sec-stick-con","position":119},{"hierarchy":{"lvl1":"Tabulation","lvl6":"Positivity/Negativity Condition","lvl5":"Modification for RLITT","lvl4":"Generation of Right Leaning Identity Weighted Planar Tangle Trees","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"type":"lvl6","url":"/tabulation#rli-gen-sec-pm-con","position":120},{"hierarchy":{"lvl1":"Tabulation","lvl6":"Positivity/Negativity Condition","lvl5":"Modification for RLITT","lvl4":"Generation of Right Leaning Identity Weighted Planar Tangle Trees","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"content":" prettier-ignore-end \n\nOur approach to the positivity and negativity condition follows our approach to the stick condition.\nWe will leverage \n\nTheorem 12 to add a check for positivity and negativity in our\nalgorithm.\n\nFind weighted planar trees by grafting \\LP+\\RP-RLITT good scions to the root of \\LP+\\RP-RLITT rootstocks\n\nInput\n\nA collection of \\LP+\\RP-RLITT good scions T_s\n\nA collection of \\LP+\\RP-RLITT rootstocks T_r\n\nOutput\n\nA collection of weighted planar trees (still not guaranteed to be RLITT)\n\nRoutine\n\nFor each combination of \\Gamma_s\\in T_s and \\Gamma_r \\in T_r\n\nCompute \\Gamma = \\Gamma_r\\star \\Gamma_s\n\nFor each vertex v_i at distance 1 from the root of \\Gamma\n\nContinue to the next iteration of the outer loop if v_i fails to satisfy the stick condition\n\nContinue to the next iteration of the outer loop if v_i fails to satisfy the positivity condition\n\nReport \\Gamma\n\nFind weighted planar trees by grafting \\LP-\\RP-RLITT good scions to the root of \\LP-\\RP-RLITT rootstocks\n\nInput\n\nA collection of \\LP-\\RP-RLITT good scions T_s\n\nA collection of \\LP-\\RP-RLITT rootstocks T_r\n\nOutput\n\nA collection of weighted planar trees (still not guaranteed to be RLITT)\n\nRoutine\n\nFor each combination of \\Gamma_s\\in T_s and \\Gamma_r \\in T_r\n\nCompute \\Gamma = \\Gamma_r\\star \\Gamma_s\n\nFor each vertex v_i at distance 1 from the root of \\Gamma\n\nContinue to the next iteration of the outer loop if v_i fails to satisfy the stick condition\n\nContinue to the next iteration of the outer loop if v_i fails to satisfy the negativity condition\n\nReport \\Gamma","type":"content","url":"/tabulation#rli-gen-sec-pm-con","position":121},{"hierarchy":{"lvl1":"Tabulation","lvl6":"Right Leaning Condition","lvl5":"Modification for RLITT","lvl4":"Generation of Right Leaning Identity Weighted Planar Tangle Trees","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"type":"lvl6","url":"/tabulation#right-leaning-condition","position":122},{"hierarchy":{"lvl1":"Tabulation","lvl6":"Right Leaning Condition","lvl5":"Modification for RLITT","lvl4":"Generation of Right Leaning Identity Weighted Planar Tangle Trees","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"content":"Satisfying the right leaning condition is a consequence of the modified \\star_i operation. Our\ndefinition of the \\star_i operation grafts the scion in such a way that weights at v_i are\nalways right of the scion. To fully satisfy the right leaning condition, we need to ensure that any\nstick subtrees are in the right most positions. This is accomplished with a slight modification of\nour grafting algorithms.\n\nFind weighted planar trees by grafting \\LP+\\RP-RLITT good scions to the root of \\LP+\\RP-RLITT rootstocks\n\nInput\n\nA collection of \\LP+\\RP-RLITT good scions T_s\n\nA collection of \\LP+\\RP-RLITT rootstocks T_r\n\nOutput\n\nA collection of RLITT\n\nRoutine\n\nFor each combination of \\Gamma_s\\in T_s and \\Gamma_r \\in T_r\n\nCompute \\Gamma = \\Gamma_r\\star \\Gamma_s\n\nShift ring subtrees of the root of \\Gamma to the right\n\nFor each vertex v_i at distance 1 from the root of \\Gamma\n\nContinue to the next iteration of the outer loop if v_i fails to satisfy the stick condition\n\nContinue to the next iteration of the outer loop if v_i fails to satisfy the positivity condition\n\nReport \\Gamma\n\nFind weighted planar trees by grafting \\LP-\\RP-RLITT good scions to the root of \\LP-\\RP-RLITT rootstocks\n\nInput\n\nA collection of \\LP-\\RP-RLITT good scions T_s\n\nA collection of \\LP-\\RP-RLITT rootstocks T_r\n\nOutput\n\nA collection of RLITT\n\nRoutine\n\nFor each combination of \\Gamma_s\\in T_s and \\Gamma_r \\in T_r\n\nCompute \\Gamma = \\Gamma_r\\star \\Gamma_s\n\nShift ring subtrees of the root of \\Gamma to the right\n\nFor each vertex v_i at distance 1 from the root of \\Gamma\n\nContinue to the next iteration of the outer loop if v_i fails to satisfy the stick condition\n\nContinue to the next iteration of the outer loop if v_i fails to satisfy the negativity condition\n\nReport \\Gamma","type":"content","url":"/tabulation#right-leaning-condition","position":123},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Full Generation Algorithm","lvl4":"Generation of Right Leaning Identity Weighted Planar Tangle Trees","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"type":"lvl5","url":"/tabulation#full-generation-algorithm","position":124},{"hierarchy":{"lvl1":"Tabulation","lvl5":"Full Generation Algorithm","lvl4":"Generation of Right Leaning Identity Weighted Planar Tangle Trees","lvl3":"Computational Methods","lvl2":"Arborescent Tangles"},"content":"The algorithm we have developed so far generates new RLITT from two restricted collections of trees.\nUnfortunately, it doesn’t yet tell us how to select the collections that guarantee the generation of\nall arborescent tangles up to a target TCN are represented. The final step in the generation scheme\nis describing how to build these collections. With computer enumeration in mind, we would like for\nour strategy to be easily split into jobs that can be run in parallel.\n\nWe observe that when grafting \\Gamma_r\\star_i\\Gamma_s=\\Gamma, the TCN r of \\Gamma_r and the\nTCN s of \\Gamma_s sum to the TCN of \\Gamma. This observation is the key underpinning of the\nstrategy we use to define discrete generation jobs. For a target TCN, we have the integer pairs seen\nin \n\n(13) that sum to the target TCN. Each of these pairs defines two classes,\ndetermined by TCN, of RLITT that can be grafted.\\begin{aligned}\n(0&,\\text{TCN})\\\\\n( 1&,\\text{TCN}-1)\\\\\n&\\vdots\\\\\n(\\text{TCN}-1&,1)\\\\\n(\\text{TCN}&,0)\n\\end{aligned}\n\nThe next question we should ask is if we can simplify the list at all. First, as we saw in the\ndiscussion of the stick condition \n\nStick Condition, we need our scions to be good. This\nmeans we cannot have 1 or 0 in the second position of the pair, excluding (\\text{TCN}-1,1) and\n(\\text{TCN},0) from the list. Second, the pair (0,\\text{TCN}) will be excluded from our list,\nsince the zero-crossing tangle \\iota[0\\ 0] can’t serve as rootstock; grafting any scion would\nviolate the stick condition. We will recover tangles with root weight 0 with a post-processing\nstep.\n\nThe following is the recursive algorithm used to take us from the set of RLITT with \\text{TCN}-1\nto the set of RLITT of the target TCN.\n\nFind RLITT of given TCN from all RLITT of TCN-1\n\nInput\n\nA target TCN\n\nAll RILTT up to TCN-1\n\nOutput\n\nA set T of all RLITT of TCN\n\nRoutine\n\nSet i=1\n\nSet N=\\text{TCN}-1\n\nSet T to the set \\LS \\iota[\\text{TCN}], \\iota[0\\ \\text{TCN}]\\RS\n\nFor each pair (i,N-i)\n\nSet T_{s+} to be the set of +-RLITT good scions with TCN\nequal to \\text{N}-i\n\nSet T_{s-} to be the set of (-)-RLITT good scions with TCN\nequal to \\text{N}-i\n\nSet T_{r+} to be the set of (+)-RLITT TCN equal to i\n\nSet T_{r-} to be the set of (-)-RLITT TCN equal to i\n\nExecute \n\nAlgorithm 13 with input T_{r-} and T_{s-}\n\nAdd the results to T\n\nExecute \n\nAlgorithm 12 with input T_{r+} and T_{s+}\n\nAdd the results to T\n\nFor every RLITT \\Gamma in T\n\nContinue to the next iteration of the loop if root of \\Gamma is valence two with weight zero\n\nCompute \\iota[0]\\star\\Gamma and add to T\n\nFind RLITT up to a given TCN\n\nInput\n\nA target TCN\n\nOutput\n\nA set T of all RLITT up to TCN\n\nRoutine\n\nSet T to be the set \\LS \\iota[0],\\ \\iota[0\\ 0],\\ \\iota[1],\\ \\iota[-1],\\ \\iota[2],\\ \\iota[-2],\\,\\ \\iota[2\\ 0],\\ \\iota[-2\\ 0]\\RS\n\nFor i from 3 to TCN\n\nExecute \n\nAlgorithm 14 with input TCN i and RLITT set\nT.\n\nAdd the results to T\n\nIt is important to note that the output of \n\nAlgorithm 15 includes duplicates in the form of\n\\LP+\\RP-RLITT and \\LP-\\RP-RLITT pairs. To deduplicate our list so it contains only topologically\nunique objects, we select from the list the collection of \\LP+\\RP-RLITT.","type":"content","url":"/tabulation#full-generation-algorithm","position":125}]}