---
title: Software and its Engineering
---

We now shift from the mathematical world to the world of computers and software.
We start with a brief overview of the goals of product management and software
engineering (@sec-product-vs-project). This includes the development of model
software engineering processes tailored for use in professional and
undergraduate mathematics research. Next, we use the engineering concepts of
@sec-product-vs-project to compare and contrast a collection of tools currently
available for use in knot theory research (@sec-surveyoftools). Using the
analysis of current tools, and our software process we define a set of
requirements and a system design for a new general purpose knot theory software
toolbox (@sec-archofktst). Finally, using this system design, and following our
process, we present documentation for the software units that satisfy the
tabulation theory of @ch-tabulation.

# Basics of Product Management and Software Engineering

```{include} ./basics/basics.md

```

<!-- prettier-ignore-start -->
(sec-surveyoftools)=
# Survey of Knot Theory Software Tools
<!-- prettier-ignore-end -->

```{include} ./survey.md

```

<!-- prettier-ignore-start -->
(sec-archofktst)=
# Architecture of A Knot Theory Software Toolbox
<!-- prettier-ignore-end -->

```{include} ./arch.md

```

<!-- prettier-ignore-start -->
(sec-unitdesign)=
# Unit Design for Tangle Tabulation
<!-- prettier-ignore-end -->

In this section, we present a collection of unit descriptions as described in
@sec-product-unit-design. Each unit will take the form of an interface defined
in @sec-system_design and give define mechanisms to wholly or partially satisfy
the each of the use cases described in @ch-tabulation.


```{include} ./documentation/core_libraries.md

```

<!-- prettier-ignore-start -->
(sec-runners)=
# Runners for Tangle Tabulation
<!-- prettier-ignore-end -->

In this section, we describe runners for the runnables defined in
@sec-unitdesign. Through this section, we will assume the existence of a global
data store. The data store is used for the storage of two sets of data, first
the long-term storage of generated tangles, and second the storage of partial
jobs to be processed by the runners.

## Rational Tangles

We saw in the use case definition for rational tangle generation as well as the
unit description satisfying that rational tangle generation is a fairly simple
process. With this simplicity, we need only to execute the rational tangle
generation component (@sec-rational_tang_gen). We implement this runner by a
Python (Cython [@behnel2011cython]) runner, this runner executes the generation
algorithm and adds the generated tangles to the datastore.

## Montesinos Tangle Generation Runner

The Montesinos generation runner takes the form of a web application. This is
accomplished by compiling the generation component with Emscripten
[@zakaiEmscriptenLLVMtoJavaScriptCompiler2011] into WebAssembly
[@WebAssemblyCoreSpecification2]. This WebAssembly is then wrapped with
JavaScript to allow communication with a job dispatching server written in
Python. Generation jobs distributed by the job server take the form of partial
sets of the twist vectors described by a stencil. The jobs are generated by
implementing @find-mont-sten as a use case of the job server. The job server is
backed by a MongoDB database, which allows for efficient lateral scaling by its
sharding mechanisms. Having the runner take this form allows for the parallel
running of generation on multiple machines.

```{include} ./job_server.md

```

## Arborescent Tangle Generation Runner

The Arborescent Tangle Generation Runner follows the same pattern and uses the
same job server as the Montesinos case. The generator is compiled into
WebAssembly and wrapped with JavaScript. Where the two runners differ is in job
generation, in the arborescent case, jobs are built by partial collections of
rootstocks and scions built on request.
